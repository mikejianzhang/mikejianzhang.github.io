<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【原】创建自签名TLS/SSL证书和私钥</title>
    <url>/2018/12/30/create-self-signed-ssl/</url>
    <content><![CDATA[<p>TLS(Transport Layer Security)-传输层安全协议，及其前身SSL(Secure Sockets Layer)-安全套接层是一种安全协议，在传输层对网络连接进行加密。TLS协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面，与具体的应用无关，所以，一般把TLS协议归为传输层安全协议。TLS握手协议使用该层中的公钥和证书来处理对等用户的认证，以及协商算法和加密实际数据传输的私钥。这个过程是在TLS记录协议的顶部执行的。TLS所采用的证书系统可以确保客户端与服务端传输的数据是被加密的，且服务端是被受信任的，但是前提是TLS所采用的证书是由信任的证书颁发机构(CA)颁发的。基于测试或内部使用的目的，本文将介绍如何创建自签名的TLS/SSL证书，如何配置Nginx使用这个自签名证书和私钥，以及如何在Linux, Windows和Mac客户端安装这个证书。需要说明的是自签名证书无法确认服务端是被受信任的。</p>
<a id="more"></a>

<h1 id="生成自签名证书和私钥"><a href="#生成自签名证书和私钥" class="headerlink" title="生成自签名证书和私钥"></a>生成自签名证书和私钥</h1><blockquote>
<p>本文是在Ubuntu 16.04系统上调用openssl工具生成自签名证书和私钥。</p>
</blockquote>
<p>使用openssl命令生成自签名证书和私钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout selfsigned-key.key -out selfsigned-certificate.crt</span><br></pre></td></tr></table></figure>

<ul>
<li>openssl: 基本命令行工具，用来创建和管理OpenSSL证书，私钥和其它文件。</li>
<li>req: 子命令，主要是用来创建和处理PKCS#10格式的证书请求。它也能创建被用作根证书的自签名证书。</li>
<li>-x509: 这个选项告诉openssl创建一个自签名证书而不是一个证书请求。</li>
<li>-nodes: 这个选项告诉openssl不要加密私钥，否则当使用在Nginx上时，每次Nginx启动都要提示输入密码。</li>
<li>-days 365: 设置证书的有效期为1年（365天）。</li>
<li>-newkey rsa:2048: 这个选项告诉openssl在生成证书的同时生成私钥。rsa:2048说明创建一个2048比特长的RSA私钥。</li>
<li>-keyout: 告诉openssl生成的私钥的名字和路径。</li>
<li>-out: 告诉openssl生成的自签名证书和路径。</li>
</ul>
<p>命令会提示以下的一些输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:Shanghai</span><br><span class="line">Locality Name (eg, city) []:Shanghai</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:&lt;The company name&gt;</span><br><span class="line">Organizational Unit Name (eg, section) []:&lt;The unit name of company&gt;</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:&lt;Domain name or Server IP address&gt;</span><br><span class="line">Email Address []:&lt;xxxx@xxx.xxx&gt;</span><br></pre></td></tr></table></figure>

<h1 id="配置Nginx使用自签名证书和私钥"><a href="#配置Nginx使用自签名证书和私钥" class="headerlink" title="配置Nginx使用自签名证书和私钥"></a>配置Nginx使用自签名证书和私钥</h1><ol>
<li><p>将证书和私钥放在Nginx服务器上某个路径下，比如”/etc/nginx/ssl-certs”；</p>
</li>
<li><p>编辑”/etc/nginx/sites-enabled”下的配置文件“*.conf”，在头部(server节点之外)加上以下两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssl_certificate       /etc/nginx/ssl-certs/selfsigned-certificate.crt;</span><br><span class="line">ssl_certificate_key   /etc/nginx/ssl-certs/selfsigned-key.key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启Nginx服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="在客户端安装自签名证书"><a href="#在客户端安装自签名证书" class="headerlink" title="在客户端安装自签名证书"></a>在客户端安装自签名证书</h1><blockquote>
<p>当自签名证书安装完后，不同的客户端程序为了能够识别和使用这个证书可能需要做不同的操作，比如docker客户端需要重新启动。</p>
</blockquote>
<h2 id="Linux客户端"><a href="#Linux客户端" class="headerlink" title="Linux客户端"></a>Linux客户端</h2><h3 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu, Debian"></a>Ubuntu, Debian</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><ol>
<li><p>将证书拷贝到目录“/usr/local/share/ca-certificates”:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp selfsigned-certificate.crt /usr/<span class="built_in">local</span>/share/ca-certificates</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新CA存储</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-ca-certificates</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol>
<li><p>从目录“/usr/local/share/ca-certificates”中删除证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/<span class="built_in">local</span>/share/ca-certificates/selfsigned-certificate.crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新CA存储</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-ca-certificates --fresh</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="CentOS-RedHat"><a href="#CentOS-RedHat" class="headerlink" title="CentOS, RedHat"></a>CentOS, RedHat</h3><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><ol>
<li><p>将证书拷贝到目录“/etc/pki/ca-trust/source/anchors”:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp selfsigned-certificate.crt /etc/pki/ca-trust/<span class="built_in">source</span>/anchors</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新CA存储</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-ca-trust</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ol>
<li><p>从目录“/etc/pki/ca-trust/source/anchors”中删除证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm /etc/pki/ca-trust/<span class="built_in">source</span>/anchors/selfsigned-certificate.crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新CA存储</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-ca-trust</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Mac客户端"><a href="#Mac客户端" class="headerlink" title="Mac客户端"></a>Mac客户端</h2><h4 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain selfsigned-certificate.crt</span><br></pre></td></tr></table></figure>

<h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo security delete-certificate -c <span class="string">"&lt;Common Name of existing certificate&gt;"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的&lt; Common Name of existing certificate&gt;是指创建证书时提示输入的Common Name (e.g. server FQDN or YOUR name) []: &lt; Domain name or Server IP address&gt;</p>
</blockquote>
<p>或者通过证书的SHA-1码来删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo security delete-certificate -Z &lt;SHA-1 Hash&gt;<span class="string">"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过命令”security find-ceritificate -a -Z -c &lt; Common Name of existing certificate&gt;”可以获得证书的SHA-1码。</p>
</blockquote>
<h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><h4 id="添加-3"><a href="#添加-3" class="headerlink" title="添加"></a>添加</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -addstore -f &quot;Root&quot; selfsigned-certificate.crt</span><br></pre></td></tr></table></figure>

<h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certutil -delstore &quot;Root&quot; &lt;Cert Serial Number&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过命令”certutil -store “Root””可以获得证书的Serial Number。</p>
</blockquote>
]]></content>
      <tags>
        <tag>System Management</tag>
        <tag>TLS/SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】创建容器化的Azure DevOps Agent</title>
    <url>/2019/12/30/docker-agent-for-azure-devops/</url>
    <content><![CDATA[<p>在一台虚拟机上安装，配置或删除Azure DevOps Agent是需要花费一些步骤和精力的，具体可以参考文档<a href="https://docs.microsoft.com/en-us/vsts/build-release/actions/agents/v2-linux?view=vsts" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/vsts/build-release/actions/agents/v2-linux?view=vsts</a>。好消息是Azure DevOps已经支持容器化的方式运行Agent。本文将详细介绍如何创建和启动一个容器化的Agent。</p>
<a id="more"></a>

<h1 id="获取Azure-DevOps-Agent的Docker镜像"><a href="#获取Azure-DevOps-Agent的Docker镜像" class="headerlink" title="获取Azure DevOps Agent的Docker镜像"></a>获取Azure DevOps Agent的Docker镜像</h1><h2 id="直接从Docker-Hub上下载"><a href="#直接从Docker-Hub上下载" class="headerlink" title="直接从Docker Hub上下载"></a>直接从Docker Hub上下载</h2><p>在我的Docker Hub空间已经有开箱即用的Docker镜像了。 打开页面<a href="https://hub.docker.com/r/mikejianzhang/azure-agent" target="_blank" rel="noopener">https://hub.docker.com/r/mikejianzhang/azure-agent</a>查看详细的下载说明。</p>
<h2 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h2><p>缺省的开箱即用的Docker镜像并没有包含过多的构建工具。如果这不满足你的需求，可以fork代码仓库<a href="https://github.com/mikejianzhang/azure-agent" target="_blank" rel="noopener">https://github.com/mikejianzhang/azure-agent</a>到自己的空间，修改Dockerfile添加更多的工具，再通过以下命令构建新的Docker镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./build.sh azure-agent:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你在公司内部构建镜像，并且需要通过代理才能访问互联网，在构建之前你需要设置http代理。构建脚本“build.sh”支持“http_proxy”, “https_proxy” and “no_proxy”。</p>
</blockquote>
<h1 id="运行Azure-DevOps-Agent的Docker镜像"><a href="#运行Azure-DevOps-Agent的Docker镜像" class="headerlink" title="运行Azure DevOps Agent的Docker镜像"></a>运行Azure DevOps Agent的Docker镜像</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>在Azure DevOps上创建Agent Pool<br><img src="1.png" alt></p>
</li>
<li><p>生成Personal Access Token<br><img src="2.png" alt></p>
</li>
</ol>
<h2 id="运行Docker镜像"><a href="#运行Docker镜像" class="headerlink" title="运行Docker镜像"></a>运行Docker镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run -it -d --name some-agent \</span><br><span class="line">        -e AZP_URL=your-azure-devops-url \</span><br><span class="line">        -e AZP_TOKEN=your-azure-devops-pat \</span><br><span class="line">        -e AZP_AGENT_NAME=some-agent \</span><br><span class="line">        -e AZP_POOL=your-azure-devops-agent-pool \</span><br><span class="line">        -e AZP_AGENTPACKAGE_URL=the-zure-devops-agent-package \</span><br><span class="line">        azure-agent:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>环境变量说明：</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>必需</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AZP_URL</td>
<td>是</td>
<td>你的 Azure DevOps server url. i.e. https://<host>/tfs</host></td>
</tr>
<tr>
<td>AZP_TOKEN</td>
<td>是</td>
<td>前面申请的有足够权限的Personal Access Token</td>
</tr>
<tr>
<td>AZP_AGENT_NAME</td>
<td>是</td>
<td>显示在Agent Pool中的Agent名字</td>
</tr>
<tr>
<td>AZP_POOL</td>
<td>是</td>
<td>Agent pool的名字</td>
</tr>
<tr>
<td>AZP_AGENTPACKAGE_URL</td>
<td>否</td>
<td>显式指定Azure Agent包的下载地址</td>
</tr>
</tbody></table>
<p>变量“AZP_AGENTPACKAGE_URL”的额外说明：<br>从容器的启动脚本“start.sh”中可以看出，容器在启动时会去某个网址上下载Azure Agent包。如果发现下载比较慢或者根本没法下载导致容器启动慢或者失败，可以提前这个包下载下来并放在内部的某个http服务器上，然后通过变量“AZP_AGENTPACKAGE_URL”把这个http链接地址传进去。</p>
<p>通过执行“start.sh”中的shell命令可以获得Azure Agent包的地址：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -LsS \</span><br><span class="line">  -u user:&lt;your-azure-devops-pat&gt; \</span><br><span class="line">  -H <span class="string">'Accept:application/json;api-version=3.0-preview'</span> \</span><br><span class="line">  <span class="string">"&lt;your-azure-devops-url&gt;/_apis/distributedtask/packages/agent?platform=linux-x64"</span></span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>利用Azure DevOps agent去执行Jenkins Job时经常会遇到下面的问题：</p>
<p>getaddrinfo ENOTFOUND …</p>
<p>解决办法是在启动容器时通过参数“–add-host”将Jenkins Server的域名和IP映射关系加到/etc/hosts中。具体如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run -it -d --name some-agent \</span><br><span class="line">        --add-host &lt;your jenkins server domain name&gt;:&lt;you jenkins server ip address&gt;</span><br><span class="line">        -e AZP_URL=your-azure-devops-url \</span><br><span class="line">        -e AZP_TOKEN=your-azure-devops-pat \</span><br><span class="line">        -e AZP_AGENT_NAME=some-agent \</span><br><span class="line">        -e AZP_POOL=your-azure-devops-agent-pool \</span><br><span class="line">        -e AZP_AGENTPACKAGE_URL=the-zure-devops-agent-package \</span><br><span class="line">        azure-agent:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Azure DevOps</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Python随笔(1) 安装Python</title>
    <url>/2020/01/31/install-python/</url>
    <content><![CDATA[<p>本文介绍了在Windows和Ubuntu中同时安装Python2和Python3。为什么要Python2和Python3共存？仅管官方已经不支持Python2了，但还是有很多Python2的程序存在，有很多Python2的库没有迁移到Python3，所以在很长的一段时间里是需要Python2和Python3的开发和运行环境共存。</p>
<a id="more"></a>

<h1 id="在Ubuntu中同时安装Python2和Python3"><a href="#在Ubuntu中同时安装Python2和Python3" class="headerlink" title="在Ubuntu中同时安装Python2和Python3"></a>在Ubuntu中同时安装Python2和Python3</h1><p>Python并没有提供Linux的官方安装说明，因为有些Linux的版本已经缺省内置了Python。这里将使用<a href="https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa" target="_blank" rel="noopener">deadsnakes PPA</a>的Apt包来安装Python。</p>
<p>下面的安装将保持Python2和Python3共存，同时设置Python2为缺省的Python。</p>
<h2 id="安装Python2"><a href="#安装Python2" class="headerlink" title="安装Python2"></a>安装Python2</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install -y software-properties-common</span><br><span class="line">sudo -E add-apt-repository -y ppa:deadsnakes/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y -f --allow-unauthenticated install python2.7-dev</span><br><span class="line">sudo ln -s /usr/bin/python2.7 /usr/bin/python</span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/bin/python</span><br><span class="line">sudo -E -H pip install virtualenv</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Ubuntu16.04中，最新的Python2版本是2.7.12，最新的Python3版本时3.7.6<br>如果在公司内安装，一般需要设置代理：</p>
<ul>
<li>HTTP/HTTPS代理<br>export http_proxy=<code>http://&lt;server&gt;:&lt;port&gt;</code><br>export https_proxy=<code>http://&lt;server&gt;:&lt;port&gt;</code><br>export ftp_proxy=<code>http://&lt;server&gt;:&lt;port&gt;</code><br>export no_proxy=localhost,127.0.0.1,xxx</li>
<li>Apt代理<br><code># BEGIN Apt Proxy</code><br>Acquire::http::Proxy <code>http://&lt;server&gt;:&lt;port&gt;</code>;<br>Acquire::https::Proxy <code>http://&lt;server&gt;:&lt;port&gt;</code>;<br>Acquire::ftp::Proxy <code>http://&lt;server&gt;:&lt;port&gt;</code>;<br><code># END Apt Proxy</code></li>
</ul>
</blockquote>
<h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y -f --allow-unauthenticated install python3.7-dev</span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py | sudo -E -H /usr/bin/python3.7</span><br></pre></td></tr></table></figure>

<h2 id="保留python2的pip为缺省pip"><a href="#保留python2的pip为缺省pip" class="headerlink" title="保留python2的pip为缺省pip"></a>保留python2的pip为缺省pip</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/pip</span><br><span class="line">sudo cp /usr/<span class="built_in">local</span>/bin/pip2 /usr/<span class="built_in">local</span>/bin/pip</span><br></pre></td></tr></table></figure>

<h1 id="在Windows中同时安装Python2和Python3"><a href="#在Windows中同时安装Python2和Python3" class="headerlink" title="在Windows中同时安装Python2和Python3"></a>在Windows中同时安装Python2和Python3</h1><p>在Windows中同时安装Python2和Python3相对来说比较容易，下载对应的安装包，按向导安装到缺省目录下即可。</p>
<div align="center">
<img src="/2020/01/31/install-python/1.png">
</div>

<p>在安装Python2向导中，选择同时安装工具pip以及将python.exe加入Path环境变量中：</p>
<div align="center">
<img src="/2020/01/31/install-python/2.png">
</div>

<p>在安装Python3向导中，选择自定义安装：</p>
<div align="center">
<img src="/2020/01/31/install-python/3.png">
</div>

<p>并选择安装工具pip：</p>
<div align="center">
<img src="/2020/01/31/install-python/4.png">
</div>

<p>将安装目录设置到和Python2相同的地方C:\Python37：</p>
<div align="center">
<img src="/2020/01/31/install-python/5.png">
</div>

<p>如果要设置Python2为缺省的Python，可以将C:\Python27;C:\Python27\Scripts放到Python3的配置前面：</p>
<div align="center">
<img src="/2020/01/31/install-python/6.png">
</div>

<h1 id="安装Python相关的模块将服务器配置为Ansible可访问的节点"><a href="#安装Python相关的模块将服务器配置为Ansible可访问的节点" class="headerlink" title="安装Python相关的模块将服务器配置为Ansible可访问的节点"></a>安装Python相关的模块将服务器配置为Ansible可访问的节点</h1><h2 id="Ansible-APT模块"><a href="#Ansible-APT模块" class="headerlink" title="Ansible APT模块"></a>Ansible APT模块</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install python-apt</span><br><span class="line">sudo apt-get -y install python3-apt</span><br><span class="line">sudo apt-get -y install  aptitude</span><br></pre></td></tr></table></figure>

<h2 id="Ansible-unarchive模块"><a href="#Ansible-unarchive模块" class="headerlink" title="Ansible unarchive模块"></a>Ansible unarchive模块</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install unzip</span><br></pre></td></tr></table></figure>

<h2 id="Ansible-mysql模块"><a href="#Ansible-mysql模块" class="headerlink" title="Ansible mysql模块"></a>Ansible mysql模块</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pip install pymysql</span><br></pre></td></tr></table></figure>

<h1 id="搭建Python虚拟开发环境"><a href="#搭建Python虚拟开发环境" class="headerlink" title="搭建Python虚拟开发环境"></a>搭建Python虚拟开发环境</h1><p>无论是开发还是运行Python程序都应该用virtualenv工具创建Python虚拟环境，并安装相关的依赖包，这样既不会污染本机的Python环境，也能保证Python程序的开发和运行的可移植性。</p>
<h2 id="Python2"><a href="#Python2" class="headerlink" title="Python2"></a>Python2</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">pythonEnv2=<span class="string">"pyenv2"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Setting up python2 running environment"</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$&#123;pythonEnv2&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Create python2 virtual environment!"</span></span><br><span class="line">    virtualenv -p python2.7 <span class="string">"<span class="variable">$&#123;pythonEnv2&#125;</span>"</span></span><br><span class="line">    curl https://bootstrap.pypa.io/get-pip.py | <span class="string">"<span class="variable">$&#123;pythonEnv2&#125;</span>/bin/python"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="string">"<span class="variable">$&#123;pythonEnv2&#125;</span>/bin/pip"</span> install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a>Python3</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">pythonEnv3=<span class="string">"pyenv3"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Setting up python3 running environment"</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$&#123;pythonEnv3&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Create python3 virtual environment!"</span></span><br><span class="line">    virtualenv -p python3.7 <span class="string">"<span class="variable">$&#123;pythonEnv3&#125;</span>"</span></span><br><span class="line">    curl https://bootstrap.pypa.io/get-pip.py | <span class="string">"<span class="variable">$&#123;pythonEnv3&#125;</span>/bin/python"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="string">"<span class="variable">$&#123;pythonEnv3&#125;</span>/bin/pip"</span> install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>requirements.txt包含了Python程序运行所需要的依赖包以及版本，基本格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ansible==2.7.10</span><br><span class="line">asn1crypto==0.24.0</span><br><span class="line">bcrypt==3.1.6</span><br><span class="line">certifi==2019.3.9</span><br><span class="line">cffi==1.12.3</span><br><span class="line">chardet==3.0.4</span><br><span class="line">cryptography==2.6.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Git随笔(1) Git合并请求(pull/merge request)的本质</title>
    <url>/2020/01/29/pullrequest-essential/</url>
    <content><![CDATA[<p>Git以及基于Git的各代码开发协作平台，比如Github, Gitlab, Bitbucket, TFS Git等正逐渐成为首选的代码版本管理工具，而基于Git的基本开发流程则是开发者创建个人的私有分支并在个人的私有分支上提交代码，代码完成后创建合并请求(pull/merge request)到主分支让相关人员做代码评审，评审通过后将合并请求(pull/merge request)合并到主分支上。合并请求(pull/merge request)不是Git本身的特性，而是各代码协作平台提供的特性，它提供的代码评审功能几乎取代了独立的代码评审工具，同时它也方便了分布于世界各地的开源代码贡献者合并自己的代码。那么合并请求(pull/merge request)到底是什么东西？它看的见摸得着吗？本文将通过目前比较流行的代码开发协作平台(Github, Gitlab, Bitbucket, TFS Git)对合并请求(pull/merget request)的实现来阐明合并请求(pull/merge request)的本质。<a id="more"></a></p>
<p>实际上，合并请求(pull/merge request)在代码层面上是Git仓库中的一个特殊分支。当开发在代码协作平台上创建并提交合并请求(pull/merge request)后，代码协作平台在服务器端将私有分支和主分支临时合并产生一个合并提交(merge commit)，同时创建一个特殊分支指向这个合并提交(merge commit)。如果临时合并出现冲突，则在Web层面显示有冲突，需要开发提交新的代码到个人分支以消除冲突。</p>
<p>要真正的理解合并请求(pull/merge request)这一特殊分支，我们需要先理解下Git的分支。</p>
<h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p>相对于传统的版本管理工具创建分支的操作，Git的分支方式及其轻巧，分支操作几乎是实时的，并且在分支之前切换也非常快。许多人认为Git这一分支模式算得上是一个“杀手级”功能。下图描述了一个含有三个文件的文件夹，且只有一个提交的Git仓库：</p>
<div align="center">
<img src="/2020/01/29/pullrequest-essential/1.png">
</div>


<p>在Git中，数据是以树形结构存储，每个文件对应着一个blob对象，每个文件夹对应着一个tree对象。每一次Git提交(commit)，都会根据文件或路径的变化创建一系列新的blog对象或tree对象，checksum不变的对象会被重复引用，其中最顶层的tree对象由于每次都需要变化，所以每次都会创建新的顶层tree对象，同时会创建一个commit对象指向新的顶层tree对象，整个过程犹如给数据做了个快照，而当前的commit对象则是这个快照的标签。如果要获取这个快照对应的代码，只要git checkout到这个commit对象即可。</p>
<p>当再次提交时，新创建的commit对象会保存一个指针指向前面的一个commit对象形成一个提交链(快照链)。下图就是Git仓库中的一个提交链：</p>
<div align="center">
<img src="/2020/01/29/pullrequest-essential/2.png">
</div>

<p>而Git中的分支则是一个轻量的可移动的指针指向其中一个commit对象。缺省的分支名字叫master，每一次新的提交master分支都会移动并指向到最新的commit对象。下图是Git中的分支和提交历史：</p>
<div align="center">
<img src="/2020/01/29/pullrequest-essential/3.png">
</div>

<p>HEAD对象是指针的指针，它指向当前所在的分支。切换分支时，只要将HEAD指向新的分支即可，所以说Git切换分支的操作是相当轻量的。</p>
<p>所以正如前文所说，合并请求(pull/merge request)也是个分支，也就是指针，它是指向私有分支和主分支临时合并后产生的合并提交(commit)对象。下图是Git中的合并请求(pull/merge request)分支：</p>
<div align="center">
<img src="/2020/01/29/pullrequest-essential/4.png">
</div>

<p>如图”defect235”分支是为了修复defect235而创建的私有分支，commit”f40ac”是代码协作平台临时合并分支”defect235”和”master”而创建的合并提交对象，分支”refs/pull/1/merge”则是那个特殊的分支，指向合并提交对象”f40ac”。不过,常规的Git克隆或者拉取是无法获取这个分支信息的，因为常规Git只会认为在缺省路径“refs/heads/“下的分支是Git分支。当开发在Web界面中合并合并请求(pull/merge request)后，私有分支”defect235”和特殊的分支也会被删除掉(通常代码协作平台会提供一些设置来控制是否要删除私有分支和合并请求分支)。下图是Git中合并请求被合并后的分支情况：</p>
<div align="center">
<img src="/2020/01/29/pullrequest-essential/5.png">
</div>

<p>不同的代码协作平台在实现合并请求(pull/merget request)的原理上是相同的，但是也有一些细微的差别。</p>
<h1 id="Github合并请求-Pull-Request"><a href="#Github合并请求-Pull-Request" class="headerlink" title="Github合并请求(Pull Request)"></a>Github合并请求(Pull Request)</h1><ul>
<li><p>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  git config --add remote.origin.fetch +refs/pull/*:refs/remotes/origin/pr/*</span><br><span class="line">  git pull --rebase</span><br><span class="line">  git branch -a</span><br><span class="line"></span><br><span class="line">  add_test</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/add_test</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/pr/1/head</span><br><span class="line">  remotes/origin/pr/1/merge</span><br><span class="line"></span><br><span class="line">  git checkout  -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

<p>origin/pr/1/head: 指向当前合并请求(pull request)中的私有分支<br>origin/pr/1/merge: 指向临时合并的提交对象</p>
</li>
<li><p>仅拉取某个合并请求(pull request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin +refs/pull/1/*:refs/remotes/origin/pr/1/*</span><br><span class="line">git checkout  -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Gitlab合并请求-Merge-Request"><a href="#Gitlab合并请求-Merge-Request" class="headerlink" title="Gitlab合并请求(Merge Request)"></a>Gitlab合并请求(Merge Request)</h1><ul>
<li><p>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(merge request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  git config --add remote.origin.fetch +refs/merge-requests/*:refs/remotes/origin/mr/*</span><br><span class="line">  git pull --rebase</span><br><span class="line">  git branch -a</span><br><span class="line"></span><br><span class="line">  change2</span><br><span class="line">  change_readme</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/change2</span><br><span class="line">  remotes/origin/change_readme</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/mr/1/head</span><br><span class="line">  remotes/origin/mr/2/head</span><br><span class="line"></span><br><span class="line">  git checkout -b mr/2 origin/mr/2/head</span><br></pre></td></tr></table></figure>

<p>origin/mr/1/head: 指向临时合并的提交对象</p>
</li>
<li><p>仅拉取某个合并请求(pull request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin +refs/merge-requests/2/*:refs/remotes/origin/mr/2/*</span><br><span class="line">git checkout -b mr/2 origin/mr/2/head</span><br></pre></td></tr></table></figure>

<h1 id="Bitbuckt合并请求-pull-Request"><a href="#Bitbuckt合并请求-pull-Request" class="headerlink" title="Bitbuckt合并请求(pull Request)"></a>Bitbuckt合并请求(pull Request)</h1><ul>
<li>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  git config --add remote.origin.fetch +refs/pull-requests/*:refs/remotes/origin/pr/*</span><br><span class="line">  git pull --rebase</span><br><span class="line">  git branch -a</span><br><span class="line"></span><br><span class="line">  fix_defect1</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/fix_defect1</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/pr/1/from</span><br><span class="line">  remotes/origin/pr/1/merge</span><br><span class="line"></span><br><span class="line">  git checkout -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>origin/pr/1/from: 指向当前合并请求(pull request)中的私有分支<br>origin/pr/1/merge: 指向临时合并的提交对象</p>
</li>
<li><p>仅拉取某个合并请求(pull request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin +refs/pull-requests/1/*:refs/remotes/origin/pr/1/*</span><br><span class="line">git checkout -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

<h1 id="TFS-Git合并请求-pull-Request"><a href="#TFS-Git合并请求-pull-Request" class="headerlink" title="TFS Git合并请求(pull Request)"></a>TFS Git合并请求(pull Request)</h1><ul>
<li>配置本地Git仓库使得每次执行Git拉取操作都能得到最新合并请求(pull request)的信息<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  git config --add remote.origin.fetch +refs/pull/*:refs/remotes/origin/pr/*</span><br><span class="line">  git pull --rebase</span><br><span class="line">  git branch -a</span><br><span class="line"></span><br><span class="line">  fix_defect1</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/fix_defect1</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/pr/1/merge</span><br><span class="line"></span><br><span class="line">  git checkout -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>origin/pr/1/merge: 指向临时合并的提交对象</p>
</li>
<li><p>仅拉取某个合并请求(pull request)的信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin +refs/pull/1/*:refs/remotes/origin/pr/1/*</span><br><span class="line">git checkout -b pr/1 origin/pr/1/merge</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，除了上面四个基于Git的代码协作平台外，还有许多优秀的平台，比如国内的码云<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a>，各大公有云平台也都提供了自己的代码协作平台。读者可以根据本文的说明自行研究合并请求(pull/merge request)。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Bitbucket</tag>
        <tag>TFS Git</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Terraform随笔(1) Terraform如何调用Ansible配置虚拟机资源</title>
    <url>/2018/11/14/terraform-call-ansible/</url>
    <content><![CDATA[<p>Terraform（<a href="https://www.terraform.io/" target="_blank" rel="noopener">https://www.terraform.io/</a>）是一款开源的基础架构即代码(Infrastructure As Code - IAC)工具，通过代码来构建和变更基础架构，并且能够管理变更的版本。Terraform在构建出虚拟机资源后，往往会调用与其关联的provisoner来配置虚拟机资源，比如变更某个系统配置，设置环境变量或者部署某个应用，但是Terraform目前并没有提供开箱即用的支持Ansible的provisioner（也许随着版本的升级，会提供）。本文基于vSphere数据中心和Ubuntu系统实现一种Terraform调用Ansible配置虚拟机资源的方法。</p>
<a id="more"></a>

<h1 id="Terraform架构简介"><a href="#Terraform架构简介" class="headerlink" title="Terraform架构简介"></a>Terraform架构简介</h1><p>为了方便后续步骤的理解，在这里对Terraform及其相关组件做一简单介绍。这是Terraform的架构图：</p>
<div align="center">
<img src="/2018/11/14/terraform-call-ansible/1.jpg">
</div>
Terraform调用不同云平台（公有或私有）的“Provider”创建和编排基础架构资源，调用不同的“Provisioner”配置新生成的资源。并不是所有的资源都支持“Provisioner”，可以参考对应资源的帮助文档来了解是否支持。基本上，虚拟机资源，比如ECS, EC2等，都支持调用“Provisioner”去配置。

<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>组合利用Terraform现有的Provisioner为新创建的虚拟机生成动态的Ansible资源文件，加入到Ansible当前资源文件夹中（Ansible在执行时会合并当前资源文件加下的所有资源文件），最后基于动态资源执行Ansible脚本配置新创建的虚拟机。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>以自动创建一台虚拟机资源并安装和配置Artifactory软件为例，下图是Terraform+Ansible的代码结构：<br>.<br>├── ansible<br>│   ├── handlers<br>│   ├── inventory<br>│   │   ├── devops<br>│   │   │   ├── group_vars<br>│   │   │   ├── host_vars<br>│   │   │   └── hosts<br>│   │   └── devops-disconf<br>│   │       └── hosts<br>│   ├── roles<br>│   ├── templates<br>│   │   ├── artifactory<br>│   │   │   └── hosts.temp.j2<br>│   ├── configure-ansible-node.sh<br>│   ├── ansible.cfg<br>│   ├── terraform-ansible-inventory.yaml<br>│   ├── artifactory.yaml<br>├── iac<br>│   └── cicd<br>│       ├── vsphere_virtual_machine_art1.tf</p>
<blockquote>
<p>Artifactory是一款统一制品管理工具，支持多种标准的软件包格式：Maven（Gradle），Nuget，NPM，Bower，CocoaPods，Docker，Debian，RPM…，也支持自定义存储格式。Artifactory是构建CI/CD流程必不可少的一个工具。</p>
</blockquote>
<h2 id="ansible目录"><a href="#ansible目录" class="headerlink" title="ansible目录"></a>ansible目录</h2><p>这个目录是典型的Ansible工程目录，有handlers，inventory，roles，templates，ansible.cfg，*.yaml（Ansible playbook）。</p>
<ul>
<li><p>ansible.cfg</p>
<p>设置缺省的资源文件夹，比如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">[defaults]</span></span><br><span class="line"><span class="string">inventory</span> <span class="string">=</span> <span class="string">./inventory/devops</span></span><br></pre></td></tr></table></figure>

<p>在资源文件夹中，一般会有一个缺省的资源文件hosts，另外还有组变量文件和主机变量文件。</p>
</li>
<li><p>configure-ansible-node.sh</p>
<p>Shell脚本，用来在新创建的虚拟机中（Ubuntu）安装Python，以便将这台虚拟机配置成Ansible的管理节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash -il</span></span><br><span class="line"></span><br><span class="line">py_version=2.7.12-1~16.04</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -f /var/lib/apt/lists/lock ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  rm -f /var/lib/apt/lists/lock</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">result=$(dpkg-query -W  python | awk <span class="string">'&#123;print $2&#125;'</span>)</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$&#123;result&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Installing python=<span class="variable">$&#123;py_version&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"python was already installed!"</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://xxxx</span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$&#123;http_proxy&#125;</span></span><br><span class="line"></span><br><span class="line">cat &gt; /etc/apt/apt.conf.d/apt-temp.conf &lt;&lt;EOF</span><br><span class="line">Acquire::http::Proxy <span class="string">"<span class="variable">$&#123;http_proxy&#125;</span>"</span>;</span><br><span class="line">Acquire::https::Proxy <span class="string">"<span class="variable">$&#123;http_proxy&#125;</span>"</span>;</span><br><span class="line">Acquire::ftp::Proxy <span class="string">"<span class="variable">$&#123;http_proxy&#125;</span>"</span>;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y --no-upgrade install python=<span class="variable">$&#123;py_version&#125;</span></span><br><span class="line"></span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py | python</span><br><span class="line">pip install -U pip</span><br><span class="line"></span><br><span class="line">rm -f /etc/apt/apt.conf.d/apt-temp.conf</span><br></pre></td></tr></table></figure>

<p>如果代码是运行在防火墙后面，比如在公司的网络中，需要line 19 - line 26的代码配置apt代理。</p>
</li>
<li><p>terraform-ansible-inventory.yaml</p>
<p>Ansible脚本，用来生成当前虚拟机的动态资源文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">Create</span> <span class="string">temp</span> <span class="string">inventory</span> <span class="string">file</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">"<span class="template-variable">&#123;&#123; host | default('localhost') &#125;&#125;</span>"</span></span><br><span class="line">  <span class="attr">vars:</span></span><br><span class="line">    <span class="attr">host_name:</span> <span class="string">default-temp</span></span><br><span class="line">    <span class="attr">host_ip:</span> <span class="string">xxx.xxx.xxx.xxx</span></span><br><span class="line">    <span class="attr">host_user:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">host_password:</span> <span class="string">xxx</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">temp</span> <span class="string">inventory</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">src=artifactory/hosts.temp.j2</span> <span class="string">dest=inventory/devops/&#123;&#123;host_name&#125;&#125;</span> <span class="string">mode=644</span></span><br><span class="line">      <span class="attr">delegate_to:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>本地执行这个Ansible脚本从以下模板（hosts.temp.j2）实例化出Ansible的资源文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;&#123;host_name&#125;&#125;</span> <span class="string">ansible_host=&#123;&#123;host_ip&#125;&#125;</span> <span class="string">ansible_user=&#123;&#123;host_user&#125;&#125;</span> <span class="string">ansible_password=&#123;&#123;host_password&#125;&#125;</span> <span class="string">ansible_ssh_common_args='-o</span> <span class="string">StrictHostKeyChecking=no'</span></span><br><span class="line"></span><br><span class="line"><span class="string">[packer_node]</span></span><br><span class="line"><span class="string">&#123;&#123;host_name&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为在动态资源文件中使用了用户名和密码的方式访问虚拟机。需要在Ansible控制机上安装sshpass。</p>
</blockquote>
</li>
</ul>
<h2 id="iac目录"><a href="#iac目录" class="headerlink" title="iac目录"></a>iac目录</h2><p>这个目录用来存放Terraform配置文件。</p>
<ul>
<li><p>vsphere_virtual_machine_art1.tf</p>
<p>Terraform配置文件，在vsphere中从某个虚拟机模板克隆创建一台新的虚拟机资源。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">provider</span> <span class="string">"vsphere"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">vsphere_server</span> <span class="string">=</span> <span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">  <span class="string">user</span>           <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">  <span class="string">password</span>       <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">  <span class="string">allow_unverified_ssl</span> <span class="string">=</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">resource</span> <span class="string">"vsphere_virtual_machine"</span> <span class="string">"art1"</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"></span><br><span class="line">  <span class="string">clone</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">template_uuid</span> <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">provisioner</span> <span class="string">"file"</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">source</span>      <span class="string">=</span> <span class="string">"../../ansible/configure-ansible-node.sh"</span></span><br><span class="line">    <span class="string">destination</span> <span class="string">=</span> <span class="string">"/tmp/configure-ansible-node.sh"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">connection</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">type</span>        <span class="string">=</span> <span class="string">"ssh"</span></span><br><span class="line">      <span class="string">user</span>        <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">      <span class="string">password</span>    <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">      <span class="string">agent</span>       <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">provisioner</span> <span class="string">"remote-exec"</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">inline</span> <span class="string">=</span> <span class="string">["chmod</span> <span class="string">a+x</span> <span class="string">/tmp/configure-ansible-node.sh",</span></span><br><span class="line">              <span class="string">"/tmp/configure-ansible-node.sh"</span><span class="string">,</span></span><br><span class="line">              <span class="string">"rm -f /tmp/configure-ansible-node.sh"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line">    <span class="string">connection</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">type</span>        <span class="string">=</span> <span class="string">"ssh"</span></span><br><span class="line">      <span class="string">user</span>        <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">      <span class="string">password</span>    <span class="string">=</span> <span class="string">"..."</span></span><br><span class="line">      <span class="string">agent</span>       <span class="string">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">provisioner</span> <span class="string">"local-exec"</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">command</span> <span class="string">=</span> <span class="string">"ansible-playbook -e host_name=default_art1 -e host_ip=$&#123;vsphere_virtual_machine.art1.default_ip_address&#125; terraform-ansible-inventory.yaml"</span><span class="string">,</span></span><br><span class="line">    <span class="string">working_dir</span> <span class="string">=</span> <span class="string">"../../ansible"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">provisioner</span> <span class="string">"local-exec"</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">command</span> <span class="string">=</span> <span class="string">"ansible-playbook  -e host=default_art1 artifactory.yaml"</span><span class="string">,</span></span><br><span class="line">    <span class="string">working_dir</span> <span class="string">=</span> <span class="string">"../../ansible"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">provisioner</span> <span class="string">"local-exec"</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">command</span> <span class="string">=</span> <span class="string">"rm -f inventory/devops/default_art1"</span><span class="string">,</span></span><br><span class="line">      <span class="string">working_dir</span> <span class="string">=</span> <span class="string">"../../ansible"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>line16 - line26：利用Terraform的”file“provisioner上传安装Python的Shell脚本</p>
</li>
<li><p>line28 - line39：利用Terraform的”remote-exec“provisioner执行安装Python的Shell脚本</p>
</li>
<li><p>line41 - line44：获取新生成的虚拟机IP地址，利用Terraform的”local-exec“provisioner本地执行“terraform-ansible-inventory.yaml”生成Ansible的动态资源文件</p>
</li>
<li><p>line46 - line49：利用Terraform的”local-exec“provisioner基于Ansible的动态资源文件执行Ansible脚本完成应用的部署和配置</p>
</li>
<li><p>line51 - line54：利用Terraform的”local-exec“provisioner执行Shell命令删除动态资源文件</p>
</li>
</ul>
</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这个方法同样也适用于在公有云平台上创建虚拟机实例并调用Ansible脚本完成配置，但需要为虚拟机实例绑定一个动态的公网IP地址。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>Infrastructure As Code</tag>
        <tag>Terraform</tag>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Jenkins随笔(2) Jenkins Job的并发执行</title>
    <url>/2019/07/08/jenkins-concurrent-builds/</url>
    <content><![CDATA[<p>并发，多线程是程序设计领域老生常谈的问题，唯一的目的就是提高程序的执行效率-充分利用资源更快地处理多个计算请求。在持续集成、交付(CI/CD)领域同样存在着并发执行的需求。本文将主要介绍Jenkins Job的并发执行以及相关问题的探讨。<a id="more"></a>其实不仅是Jenkins，任何一个持续集成(CI)服务器都应该支持CI Job的并发执行，其原因有以下两点：</p>
<ul>
<li>充分利用Slave资源。如果让一台VM Slave一次只处理一个CI请求，往往会浪费很多的资源（CPU，Memory，Storage）。</li>
<li>持续集成的最佳实践要求快速地“Build Per Change Commit”，但是对于一些比较耗时的持续集成流水线，比如项目比较大，或者自动化测试的时间比较长，往往是前一个集成还没结束，新的change commit已经到来，如果不能并发执行，只能阻塞等待，导致commit的提交者不能及时得到反馈，从而使持续集成流水线在项目中失去了应有的作用，地位也会变得比较尴尬。此时，如果再一味地推进与持续集成流水线配套的一些策略，将会受到很大的阻力。</li>
</ul>
<h1 id="Jenkins-Job缺省的并发行为"><a href="#Jenkins-Job缺省的并发行为" class="headerlink" title="Jenkins Job缺省的并发行为"></a>Jenkins Job缺省的并发行为</h1><p>随着Jenkins Pipeline2.0的引入，目前主要有三种类型的Jenkins Job：Free Style Job，Scripted Pipeline and Declarative Pipeline。Scripted Pipeline and Declarative Pipeline属于Jenkins Pipeline2.0引入的Job类型，最大的优点就是Pipeline as Code，在一个Jenkinsfile文件里可以编写整个CI流程，并且可以提交到代码仓库，比如Git，作版本管理。由于Pipeline2.0突出的优点，目前越来越多的公司和组织开始使用它来构建持续集成和持续交付流水线，但是Free Style类型的Job目前还是主要支持的Job类型之一，没有被废弃掉，其原因可能有两个：1，并不是所有的插件都能够很好地支持Pipeline2.0（下一节的Throttle Concurrent Builds Plugin就是个例子）；2，不少公司或组织还有很多遗留的Free Style类型的Job，所以本文仍然会涉及这三个类型的Job。</p>
<p>为了支持Jenkins Job并发执行，首先需要设置Jenkins Slave的Build Executors的数量大于1：<br><img src="1.png" alt></p>
<p>当Jenkins Job有新的build请求时，只要匹配的Slave节点有空闲的Executor，即使已经有build在执行，新的build也会立刻被并发执行。如果匹配的Slave节点没有空闲的Executor，这个新的build请求将被放入待执行队列里等待调度。</p>
<p>Free Style Job缺省并没有打开并发执行的功能。需要在Job的配置中打开选项“Execute concurrent builds if necessary”：<br><img src="2.png" alt></p>
<p>Pipeline2.0的Job缺省是并发执行模式。如果要禁止并发执行，可以通过添加以下代码：</p>
<ul>
<li>Scripted Pipeline</li>
</ul>
<p>在Jenkinsfile头部添加以下属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">properties(</span><br><span class="line">  [</span><br><span class="line">      disableConcurrentBuilds()</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>Declarative Pipeline</li>
</ul>
<p>在pipeline块中添加以下选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    options &#123;</span><br><span class="line">        disableConcurrentBuilds()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Jenkins-Job并发执行需要解决的问题"><a href="#Jenkins-Job并发执行需要解决的问题" class="headerlink" title="Jenkins Job并发执行需要解决的问题"></a>Jenkins Job并发执行需要解决的问题</h1><p>Jenkins Job的并发执行是一把双刃剑，用得好，所向披靡，能够充分利用既有资源服务更多的持续集成请求，用得不好，会出现很多预料不到的问题，而且有些问题并不能重复出现，给调试带来了很大的负担。Jenkins Job的并发执行主要面临的问题是资源使用的冲突。下图是一个常见的基于Pipeline2.0实现的一个Jenkins CI Job(yunzai-ci)：<br><img src="3.png" alt>按照流程顺序，逐一分析如下：</p>
<ul>
<li><p>在“Checkout Code”阶段，同一个Jenkins Job并发执行的build在同一个Slave上的Workspace会存在着冲突。对于这个问题，其实Jenkins已经提供了解决方案，细心的你一定会发现在Slave机子上同一个Job会存在着多个文件夹，比如“yunzai-ci”，“yunzai-ci@1”，“yunzai-ci@2”…，这就是同一个Job并发执行的build对应的不同的Workspace。Jenkins缺省是在Job的名字后面加上符号@和数字来命名不同的Workspace的，当并发执行的build数量大于Workspace的数量，Jenkins会根据命名规则自动创建一个新的Workspace，当并发执行的build数量小于Workspace数量，Jenkins会按顺序重用已有的Workspace。</p>
<blockquote>
<p>Workspace的分隔符@可以在启动Jenkins master时设置Java系统属性“hudson.slaves.WorkspaceList”来改变。比如，“hudson.slaves.WorkspaceList=-”将Workspace的分隔符改为中划线。</p>
</blockquote>
<p>Workspace的冲突解决了，但是又引入了一个潜在的效率问题。想象一下，如果项目的代码库比较大(几百兆，或者几个G)，那么在创建一个新的Workspace时，会重新从远处的代码仓库克隆代码，这将导致当前Jenkins job执行的时间被拉长。可以优化Jenkins Job，通过拷贝本地已有Workspace的代码来提升速度(Linux上可以使用Rsync，Window上可以使用Robocopy)，而不是直接从远程代码仓库去克隆代码。</p>
</li>
<li><p>在“Build/UT”阶段，会使用不同的自动构建工具和包管理工具，比如Maven, Gradle, Npm, Bower等等，构建出来的制品会上传到制品仓库(Artifactory或Nexus)。这里，自动构建工具的本地缓存，以及构建制品上传到制品仓库都可能存在冲突。比如Maven, 缺省的本地缓存是在当前用户的.m2目录下，Maven执行时会更新或者下载项目的依赖到本地缓存，或者安装当前构建的制品到本地缓存，当同一个Jenkins Job并发执行的build运行在同一个Jenkins Slave上时，会启动多个Maven进程同时执行，它们会下载同一个依赖包或者安装相同版本(Maven的snapshot版本或者其它原因导致两个build版本相同)的构建制品到到同一个缓存目录，这时就会经常出现写磁盘文件冲突的问题，而且这个问题不是每次都发生。当多个Maven进程同时上传相同版本的制品到制品仓库时，也会存在着冲突。<br>要解决这类型的冲突，需要具体情况，具体对待。对于Maven来说，可以通过属性”maven.repo.local”来为每个Maven进程指定不同的本地缓存目录，且保证每个Build的版本都是唯一的。这个解决方案同样存在着效率问题，每开一个新的Maven本地缓存目录都会增加build的执行时间，因为Maven要重新去下载项目的所有依赖，这时也可以通过拷贝本地已有的缓存目录来提升速度。</p>
</li>
<li><p>在“Code Static Check”阶段，如果使用的是SonarQube，则不会产生冲突，因为每一个并发执行的build都会在SonarQube服务端产生一个独立的分析，所以不会相互干扰。但如果是其它的静态代码分析服务器，可能就需要具体情况，具体对待。</p>
</li>
<li><p>在“自动化测试”阶段，由于资源有限(自动化测试机器有限，而且执行自动化测试用例也需要一定的时间)，所以不一定能够服务于并发执行的多个build。这时可以增加自动化测试机器(虚拟机)，同时进行测试分级，抽取出部分重要的测试用例放到Jenkins Job中去执行以降低测试执行的时间。可以把全量测试降级为以天为单位，比如每晚取最新的build去执行全量测试，并给出测试报告。</p>
</li>
</ul>
<p>不同公司或组织的持续集成流水线可能和上文描述的不相同，为了能够并发执行Jenkins Job，需要逐一分析和解决每个阶段可能出现的资源冲突问题。</p>
<h1 id="Jenkins-Job并发执行的精确控制-Throttle-Concurrent-Builds-Plugin"><a href="#Jenkins-Job并发执行的精确控制-Throttle-Concurrent-Builds-Plugin" class="headerlink" title="Jenkins Job并发执行的精确控制(Throttle Concurrent Builds Plugin)"></a>Jenkins Job并发执行的精确控制(Throttle Concurrent Builds Plugin)</h1><p>Jenkins Job缺省的并发行为是只要有足够可用的Jenkins Slave和Executor资源，启动的build数量是不限的。但实际情况是我们需要精确地控制某个Jenkins Job总的并发执行的build数量，同时也希望单个Jenkins Slave节点上同一个Jenkins Job并发执行的build数量，这样可以限制某个Jenkins Job的总体资源消耗，保证其它Jenkins Job也能均衡执行。借助于Jenkins插件“Throttle Concurrent Builds Plugin”可以达到这样的控制目的。“Throttle Concurrent Builds Plugin”支持系统级别的配置，也支持Job级别的配置：</p>
<ul>
<li><p>系统级别的配置：<br><img src="4.png" alt>系统级别的配置可以设置一个并发执行的类别，不同的Jenkins Job可以引用这个类别。<br>“Maximum Total Courrent Builds”用来设置Jenkins Job最大的并发数量。<br>“Maximum Concurrent Builds Per Node”用来设置同一个Jenkins Job在同一个Slave节点上最大的并发数量。</p>
</li>
<li><p>Free Style Job级别的配置：<br><img src="5.png" alt>在Job级别，可以选择“Throttle this project alone”，并且设置“Maximum Total Courrent Builds”和“Maximum Concurrent Builds Per Node”这两个值，也可以通过“Multi-Project Throttle Category”选择系统级别配置好的并发执行的类别。</p>
</li>
<li><p>Scripted Pipeline只支持使用系统级别配置好的并发执行类别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throttle([&apos;test-cocurrent&apos;]) &#123;</span><br><span class="line">  node(&apos;xxxx&apos;) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于Declarative Pipeline，目前“Throttle Concurrent Builds Plugin”还不支持，所以只能是前面讨论的缺省并发行为。</p>
</li>
</ul>
<blockquote>
<p>对于插件“Throttle Concurrent Builds Plugin”的详细用法，<br>可以参考插件的Wiki: <a href="https://wiki.jenkins.io/display/JENKINS/Throttle+Concurrent+Builds" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Throttle+Concurrent+Builds+Plugin</a>和GitHub地址: <a href="https://github.com/jenkinsci/throttle-concurrent-builds-plugin" target="_blank" rel="noopener">https://github.com/jenkinsci/throttle-concurrent-builds-plugin</a>。</p>
</blockquote>
<h1 id="Jenkins-Job相同参数build的执行情况"><a href="#Jenkins-Job相同参数build的执行情况" class="headerlink" title="Jenkins Job相同参数build的执行情况"></a>Jenkins Job相同参数build的执行情况</h1><p>所谓相同参数build，就是指同一个Jenkins Job以相同的参数触发多个build。不论是Jenkins Job并发执行，还是非并发执行，只要有符合Jenkins Job执行的Slave和Executor资源而且并发策略允许，所有被触发的build都会被立刻执行。但如果没有足够的执行资源，或者并发策略不允许，而且已经有build在待执行队列里等待的情况下，再次触发与等待的build参数相同的build，行为就会有些区别，总结如下：</p>
<table>
<thead>
<tr>
<th>Job类型</th>
<th>并发执行</th>
<th>非并发执行</th>
</tr>
</thead>
<tbody><tr>
<td>Free Style Job</td>
<td>相同参数的build只会加入到待执行队列一次</td>
<td>相同参数的build只会加入到待执行队列一次</td>
</tr>
<tr>
<td>Scripted Pipeline</td>
<td>相同参数的build会重复加入到待执行队列</td>
<td>相同参数的build只会加入到待执行队列一次</td>
</tr>
<tr>
<td>Declarative Pipeline</td>
<td>相同参数的build会重复加入到待执行队列</td>
<td>相同参数的build只会加入到待执行队列一次</td>
</tr>
</tbody></table>
<p>以上是根据实测得到的结果，并没有任何官方文档提供详细的说明，所以随着Jenkins版本的升级，其行为有可能会变化。</p>
<h1 id="容器作为Slave节点会让并发执行变得容易吗？"><a href="#容器作为Slave节点会让并发执行变得容易吗？" class="headerlink" title="容器作为Slave节点会让并发执行变得容易吗？"></a>容器作为Slave节点会让并发执行变得容易吗？</h1><p>最近几年容器技术借助于Docker在IT领域里掀起了巨大的变革，容器编排平台Kubernetes的出现更是将容器化的应用推向高潮。在CI/CD领域也不例外，越来越多的组织开始尝试利用Docker容器作为CI Job执行的Slave节点，通过Kubernetes平台统一管理调度虚拟机资源，以期望更加细粒度地控制和使用计算资源。Docker容器作为Slave节点确实是实现了本地执行环境的隔离，但每次执行都会启动全新的容器，都得重新下载代码和构建工具的本地缓存，使得每次的构建都要花费更长的时间，所以还是要考虑如何提升效率。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Jenkins随笔(4) Jenkins构建Bitbucket合并请求(Pull Request)</title>
    <url>/2020/02/23/jenkins-bibucket-pullrequest/</url>
    <content><![CDATA[<p>在<a href="http://www.mikesay.com/2020/01/30/jenkins-github-pullrequest/">“Jenkins随笔(3)  Jenkins构建Github合并请求(Pull Request)”</a>中介绍了用Jenkins构建Github合并请求(Pull Request)的方法以及preflight流水线的意义。本文将继续介绍如何配置Jenkins和Bitbucket来构建Bitbucket合并请求(Pull Request)。</p>
<a id="more"></a>
<p>Bitbucket官网提供了以下两种方法来配置Jenkins构建Bitbucket合并请求(Pull Request):</p>
<ol>
<li>Jenkins <a href="https://plugins.jenkins.io/git/" target="_blank" rel="noopener">Git插件</a>结合Bitbucket插件<a href="https://marketplace.atlassian.com/apps/1211284/webhook-to-jenkins-for-bitbucket/version-history" target="_blank" rel="noopener">Webhook to Jenkins for Bitbucket</a></li>
<li>Jenkins <a href="https://plugins.jenkins.io/cloudbees-bitbucket-branch-source/" target="_blank" rel="noopener">Bitbucket Branch Source</a>插件</li>
</ol>
<p>方法1中的Bitbucket插件Webhook to Jenkins for Bitbucket是商业版的，需要收费，个人觉得不值得，也没有尝试。方法2中的Jenkins Bitbucket Branch Source插件适合于Jenkins多分支流水线， 也不是本文讨论的范围。除此之外，Jenkins还有这三个插件可用：</p>
<ul>
<li>Jenkins <a href="https://plugins.jenkins.io/bitbucket-pullrequest-builder/" target="_blank" rel="noopener">Bitbucket Pullrequest Builder</a>插件</li>
<li>Jenkins <a href="https://plugins.jenkins.io/bitbucket/" target="_blank" rel="noopener">Bitbucket</a>插件</li>
<li>Jenkins <a href="https://plugins.jenkins.io/bitbucket-push-and-pull-request/" target="_blank" rel="noopener">Bitbucket Push and Pull Request</a>插件</li>
</ul>
<p>Bitbucket Pullrequest Builder插件有一些严重的问题<a href="https://plugins.jenkins.io/bitbucket-pullrequest-builder/" target="_blank" rel="noopener">(https://plugins.jenkins.io/bitbucket-pullrequest-builder/)</a>，所以不能采用。Bitbucket插件是目前网上大部分文章讨论用到的插件，但是测试下来发现个问题，即提交代码到现有的合并请求(Pull Request)不会触发新的合并请求(Pull Request)的构建，这个问题首先是Bitbucket Webhook并没有提供一个这样的事件(<a href="https://community.atlassian.com/t5/Bitbucket-questions/How-to-trigger-a-webhook-when-a-commit-is-pushed-to-an-open-pull/qaq-p/1029556" target="_blank" rel="noopener">网上也有类似的讨论</a>)，其次Bitbucket插件也没有提供足够的灵活性方便解决它。最终测试下来觉得Bitbucket Push and Pull Request插件可以使用，首先它是从Bitbucket插件继承过来的，包含了Bitbucket插件的所有功能，其次通过使用Bitbucket Push and Pull Request插件，可以配置一个临时的方法解决我们发现的Bitbucket插件和Bitbucket Webhook的问题。下面将详细介绍利用Jenkins Bitbucket Push and Pull Request插件来构建Bitbucket合并请求(Pull Request)。</p>
<h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装Bitbucket-Push-and-Pull-Request插件"><a href="#安装Bitbucket-Push-and-Pull-Request插件" class="headerlink" title="安装Bitbucket Push and Pull Request插件"></a>安装Bitbucket Push and Pull Request插件</h2><ol>
<li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p>
</li>
<li><p>打开Available页面，选择Github Pull Request Builder，点击Install without restart按钮</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/1.png">
</div>
</li>
<li><p>必要时重启Jenkins让插件生效</p>
</li>
</ol>
<p>安装完插件后，生成的Web hook url地址为<code>http://&lt;jenkins url&gt;/bitbucket-hook/</code>。</p>
<h1 id="配置Bitbucket代码仓库"><a href="#配置Bitbucket代码仓库" class="headerlink" title="配置Bitbucket代码仓库"></a>配置Bitbucket代码仓库</h1><ol>
<li><p>点击”Repository settings” -&gt; “Webhooks”打开Webhooks创建页面</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/2.png">
</div>
</li>
<li><p>点击”Create webhook”按钮打开添加Webhook页面</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/3.png">
</div>

</li>
</ol>
<p>添加以下的信息后点击保存按钮创建新的Webhook:</p>
<ul>
<li>URL: 设置为Bitbucket Push and Pull Request插件生成的Web hook url地址：<code>http://&lt;jenkins url&gt;/bitbucket-hook/</code></li>
<li>Pull request事件: 选择”Opened”和”Modified”</li>
<li>Repository事件: 选择”Push”<blockquote>
<p>这里选择Push事件是为了解决文章开头提到的Bitbucket插件和Bitbucket Webhook的问题，即提交代码到已有的合并请求(Pull Request)不会触发新的合并请求(Pull Request)的构建。</p>
</blockquote>
</li>
</ul>
<h1 id="创建Jenkins-pipeline-job用来构建合并请求-pull-merge-request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-pull-merge-request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(pull/merge request)"></a>创建Jenkins pipeline job用来构建合并请求(pull/merge request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">'common'</span></span><br><span class="line">    &#125;</span><br><span class="line">    triggers &#123;</span><br><span class="line">        bitBucketTrigger(</span><br><span class="line">            [</span><br><span class="line">                [</span><br><span class="line"><span class="symbol">                    $class:</span> <span class="string">'BitBucketPPRPullRequestServerTriggerFilter'</span>,</span><br><span class="line"><span class="symbol">                    actionFilter:</span> [<span class="string">$class:</span> <span class="string">'BitBucketPPRPullRequestServerCreatedActionFilter'</span>, <span class="string">allowedBranches:</span> <span class="string">''</span>]</span><br><span class="line">                ], </span><br><span class="line">                [</span><br><span class="line"><span class="symbol">                    $class:</span> <span class="string">'BitBucketPPRPullRequestServerTriggerFilter'</span>, </span><br><span class="line"><span class="symbol">                    actionFilter:</span> [<span class="string">$class:</span> <span class="string">'BitBucketPPRPullRequestServerUpdatedActionFilter'</span>, <span class="string">allowedBranches:</span> <span class="string">''</span>]</span><br><span class="line">                ],</span><br><span class="line">                [</span><br><span class="line"><span class="symbol">                    $class:</span> <span class="string">'BitBucketPPRRepositoryTriggerFilter'</span>, </span><br><span class="line"><span class="symbol">                    actionFilter:</span> [</span><br><span class="line"><span class="symbol">                                    $class:</span> <span class="string">'BitBucketPPRServerRepositoryPushActionFilter'</span>, </span><br><span class="line"><span class="symbol">                                    allowedBranches:</span> <span class="string">''</span>, </span><br><span class="line"><span class="symbol">                                    triggerAlsoIfNothingChanged:</span> <span class="literal">true</span>, </span><br><span class="line"><span class="symbol">                                    triggerAlsoIfTagPush:</span> <span class="literal">false</span></span><br><span class="line">                                ]</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        BITBUCKET_URL = <span class="string">"http://130.147.249.221:7990"</span></span><br><span class="line">        BITBUCKET_ORG = <span class="string">"miks"</span></span><br><span class="line">        BITBUCKET_REPO = <span class="string">"mikesay-test-1"</span></span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout()</span><br><span class="line">        ansiColor(<span class="string">'xterm'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Checkout'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                    <span class="keyword">def</span> scmVars =   checkout(</span><br><span class="line">                                        [<span class="string">$class:</span> <span class="string">'GitSCM'</span>, <span class="string">branches:</span> [[<span class="string">name:</span> <span class="string">"origin/pr/*/merge"</span>]], </span><br><span class="line"><span class="symbol">                                        doGenerateSubmoduleConfigurations:</span> <span class="literal">false</span>,</span><br><span class="line"><span class="symbol">                                        submoduleCfg:</span> [], </span><br><span class="line"><span class="symbol">                                        extensions:</span> [</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'RelativeTargetDirectory'</span>, <span class="string">relativeTargetDir:</span> <span class="string">'codes'</span>],</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'CleanBeforeCheckout'</span>]</span><br><span class="line">                                        ],</span><br><span class="line"><span class="symbol">                                        userRemoteConfigs:</span> [</span><br><span class="line">                                                [</span><br><span class="line"><span class="symbol">                                                    credentialsId:</span> <span class="string">'ghe_account'</span>, </span><br><span class="line"><span class="symbol">                                                    name:</span> <span class="string">'origin'</span>, </span><br><span class="line"><span class="symbol">                                                    refspec:</span> <span class="string">'+refs/pull-requests/*:refs/remotes/origin/pr/*'</span>, </span><br><span class="line"><span class="symbol">                                                    url:</span> <span class="string">"$&#123;BITBUCKET_URL&#125;/scm/$&#123;BITBUCKET_ORG&#125;/$&#123;BITBUCKET_REPO&#125;.git"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                            ]</span><br><span class="line">                                        ]</span><br><span class="line">                                    )</span><br><span class="line">                    env.GIT_BRANCH = <span class="string">"$&#123;scmVars.GIT_BRANCH&#125;"</span></span><br><span class="line">                    env.GIT_COMMIT = <span class="string">"$&#123;scmVars.GIT_COMMIT&#125;"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                dir(<span class="string">'codes'</span>) &#123;</span><br><span class="line">                    sh <span class="string">'''#!/bin/bash -l</span></span><br><span class="line"><span class="string">                        echo "Start building!"</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8行-24行: 配置Job触发事件，分别是合并请求(Pull Request)的创建(Create)，更新(Update)事件，以及Git仓库的推送(Push)事件，同时设置”triggerAlsoIfNothingChanged”的值为true。勾选Git仓库的推送(Push)事件和设置”triggerAlsoIfNothingChanged”的值为true是为了过滤前面Webhook中设置的Git仓库的推送(Push)事件，这样当有新的提交推送到合并请求(Pull Request)后，Job也能被触发。</p>
<p>53行：设置拉取合并请求(Pull Request)的配置。可以参考之前的文章<a href="http://www.mikesay.com/2020/01/29/pullrequest-essential/">“Git随笔(1) Git合并请求(pull/merge request)的本质”</a>。</p>
<p>42行：构建分支设置为<code>origin/pr/*/merge</code>，这样可以构建所有合并请求(Pull Request)对应的分支。Bitbucket Push and Pull Request插件在触发构建时会传递一个环境变量”BITBUCKET_PULL_REQUEST_ID”到构建Job中，这个环境变量的值就是合并请求(Pull Request)的ID号。利用这个环境变量可以将构建分支设置的更精确一点，比如<code>origin/pr/${BITBUCKET_PULL_REQUEST_ID}/merge</code>，但只有合并请求(Pull Request)的创建，关闭和重新打开的事件触发的构建Job才会传递这个变量，所以不怎么通用。</p>
<blockquote>
<p>将构建分支设置为通用的合并请求(Pull Request)分支也带来了个缺陷，就是当构建Job创建好后，必须手动触发多次以获取所有未完成的合并请求(Pull Request)分支的信息以便后续合并请求(Pull Request)有更新时，能够触发正确的构建。</p>
</blockquote>
<h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol>
<li><p>点击”New Item”</p>
</li>
<li><p>选择Job类型为”Pipeline”，输入Job的名字，比如”bitbucket-preflight”，点击”Ok”按钮</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/4.png">
</div>
</li>
<li><p>在”Pipeline”段，引用Jenkinsfile(Jenkinsfile是单独放在一个独立的Git仓库中的)</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/5.png">
</div>
</li>
<li><p>点击”Save”按钮保存Jenkins Job</p>
</li>
<li><p>手动触发Jenkins Job多次以获取所有未完成的合并请求(Pull Request)分支的信息。如果目前没有未完成的合并请求(Pull Request)，也需要手动触发Job一次让Jenkinsfile中设置的触发规则配置到job中。</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/6.png">
</div>

</li>
</ol>
<h1 id="创建合并请求-pull-merge-request-触发构建"><a href="#创建合并请求-pull-merge-request-触发构建" class="headerlink" title="创建合并请求(pull/merge request)触发构建"></a>创建合并请求(pull/merge request)触发构建</h1><ol>
<li><p>Bitbucket的合并请求(pull/merge request)</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/7.png">
</div>
</li>
<li><p>触发的构建</p>
<div align="center">
<img src="/2020/02/23/jenkins-bibucket-pullrequest/8.png">
</div>

</li>
</ol>
<p>细心的读者可能发现，和Github合并请求(Pull Request)的构建相比少了很多有用的信息，比如构建描述中没有显示合并请求(Pull Request)号，不太容易知道当前的构建是由哪个合并请求(Pull Request)触发的，而在合并请求(Pull Request)的页面中也看不到当前构建的状态。这些都是由Jenkins插件提供的功能多少决定的，对于Bitbucket合并请求(Pull Request)的构建，我们需要更多的自定义工作以提供足够多的信息，比如从当前构建中获取合并请求(Pull Request)分支，提取出合并请求(Pull Request)号并且设置到构建描述中。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Git</tag>
        <tag>Bitbucket</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Jenkins随笔(1) 基于Jenkins Freestyle Job构建CI/CD流水线</title>
    <url>/2018/10/07/jenkins-freestyle-cicd-pipeline/</url>
    <content><![CDATA[<p>可能有人会问：“现在流行的是Jenkins Pipeline 2.0(Jenkinsfile)，所有人都在谈论和使用, 为什么还在用Freestyle Job, 是不是太low了！”。的确，Jenkins Pipeline 2.0现在很流行，几乎就等同于Jenkins平台上构建CI/CD流水线的标准，如果你不使用Jenkins Pipeline 2.0，那么就等于不懂CI/CD。我承认Jenkins Pipeline 2.0带来了很多革命性的理念，比如Build As Code, 但是我想说的是Jenkins Pipeline 2.0不等于CI/CD Pipeline,而且它的革命也不是很彻底。不过本文不会过多地去议论方法或工具的好坏，只是在Jenkins上利用一种非Jenkins Pipeline 2.0的方式去构建CI/CD流水线，并说明这种流水线的优缺点，以期能够给读者一次思维上的刷新。</p>
<a id="more"></a>

<h1 id="一个典型的CI-CD流水线"><a href="#一个典型的CI-CD流水线" class="headerlink" title="一个典型的CI/CD流水线"></a>一个典型的CI/CD流水线</h1><div align="center">
<img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/2.png">
</div>

<p>上图是个典型的CI/CD流水线，由5个阶段（Phase）组成：Build/UT，Code Static Check，QA，STAGE和PROD。每个阶段（Phase）由一到多个任务（Task）组成，每个阶段（Phase）都有一个主任务（Task），阶段（Phase）之间的提升（Promotion）是由主任务（Task）的提升（Promotion）完成。同一个阶段（Phase）之间的任务（Task）可以串行执行，也可以并行执行。</p>
<p>如果一个任务（Task）是通过提升（Promotion）的方式触发的，那么在当前流水线中这个任务（Task）可以被重复触发。这为流水线带来了两个好处：</p>
<ul>
<li><p>流水线可以从失败的点重新启动，而无需重新启动一个新的流水线实例：<br>当一个任务（Task）的执行由于某种临时原因失败了，比如网络不稳定，磁盘空间满了，断电等，可以通过重新提升（Promotion）再次触发。尤其是在前置阶段（Phase）和任务（Task）比较耗时，或者需要征用外部资源的时候，这一点更显得重要。</p>
</li>
<li><p>调试CI/CD流水线时，无需重复启动一个新的流水线实例：<br>这一点其实是上优点的延伸。调试流水线时往往是从前往后一个阶段（Phase）一个阶段（Phase）的调试，正是由于流水线可以从失败的点重新启动，可以直接略过通过的阶段（Phase），从失败的阶段（Phase）开始调试。</p>
</li>
</ul>
<p>手动提升（Manual Promote）策略需要有权限的批准者根据提前制定好的质量关卡来决定是否需要提升（Promote）到下一个阶段（Phase）。在这个流水线中，QA阶段（Phase）到STAGE阶段（Phase），STAGE阶段（Phase）到PROD阶段（Phase）都需要手动提升（Mannual Promote），它们并不是在每一个流水线实例中都需要被触发。在开发的早期，软件还不是很稳定的时候，每一次的代码提交都会触发一个流水线实例，流水线实例往往会根据自动提升（Auto Promote）策略最大限度地往后续阶段（Phase）流转，如果在某一阶段（Phase）失败了，则会及时通知到相关开发人员，从而实现了及时反馈当前代码提交对软件质量的影响。</p>
<p>只要没有被清理掉， 流水线实例可以在任何时间被重新启动，状态也会自动恢复。这为流水线带来了以下的好处：</p>
<ul>
<li><p>有时候由于质量和时间的原因，不一定会将最新版本的流水线实例从STAGE阶段（Phase）提升到PROD阶段（Phase），而是需要将几天前的已经处于STAGE阶段（Phase）的流水线实例提升到PROD阶段（Phase）；</p>
</li>
<li><p>流水线在停止状态不会占用任何Jenkins Master 或者 Slave节点资源。</p>
</li>
</ul>
<blockquote>
<p>往往是在第一个阶段（Phase）的构建（Build）任务（Task）中生成状态文件，后续阶段（Phase）只是拷贝和恢复，也有可能会添加更多的状态。</p>
</blockquote>
<p>下图是状态存储与恢复的过程。</p>
<div align="center">
<img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/3.png">
</div>

<p>在上游阶段（Phase）的任务（Task）也就是Jenkins作业（Job）中将需要持久的状态以key-value的方式存储到build-info.prop文件中，并通过Jenkins Job的存档功能（Archive）将build-info.prop存到当前作业（Job）上，下游被触发的Jenkin作业（job）将上游作业（Job）的build-info.prop拷贝到本地工作区，将它注入为环境变量。</p>
<h1 id="在Jenkins上实现这个CI-CD流水线"><a href="#在Jenkins上实现这个CI-CD流水线" class="headerlink" title="在Jenkins上实现这个CI/CD流水线"></a>在Jenkins上实现这个CI/CD流水线</h1><h2 id="Jenkins和必要的插件"><a href="#Jenkins和必要的插件" class="headerlink" title="Jenkins和必要的插件"></a>Jenkins和必要的插件</h2><ol>
<li><p>Jenkins<br>从Jenkins官网（<a href="https://jenkins.io" target="_blank" rel="noopener">https://jenkins.io</a>）上下载最新版本的Jenkins并安装。或者，至少保证你的Jenkins版本在2.0以上，1.x版本还是太旧了。</p>
</li>
<li><p>必要的插件</p>
<ul>
<li><p>Parameterized Trigger Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Parameterized+Trigger+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Parameterized+Trigger+Plugin</a></p>
<p>在Jenkins pipeline2.0之前，Job之前的调用与被调用关系是通过这个插件或者一系列同类的插件实现的。</p>
</li>
<li><p>Delivery Pipeline Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Delivery+Pipeline+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Delivery+Pipeline+Plugin</a></p>
<p>将Job的上下游调用关系图形化显示为流水线。这个插件实现了CI/CD流水线的两个概念：阶段（Phase）和任务（Task）。一个任务（Task）就是一个Jenkins Freestyle Job（作业），一个阶段（Phase）可以包含多个任务（Task）。下图是从插件的网站上截取出来的最终CI/CD流水线的样式：</p>
<div align="center">
<img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/1.png">
</div>
</li>
<li><p>Promte Builds Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Promoted+Builds+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Promoted+Builds+Plugin</a></p>
<p>这个插件提供了一系列上下游作业（Job）之间的触发策略，主要分为自动触发，手动批准触发和自定义条件触发。除了三种主要的触发策略，还提供了一些更精细的控制策略，比如当前的提升（promotion）依赖于另一个提升（promotion）。可参考插件的wiki文档和内联的注释详细了解每一个触发策略，选中适合当前CI/CD流水线建设的要求。</p>
</li>
<li><p>Copy Artifact Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Copy+Artifact+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Copy+Artifact+Plugin</a></p>
<p>这个插件实现了实现了上下游作业（Job）传递数据的功能。在构建CI/CD流水线时，会将流水线的状态数据以key-value值的方式记录在文本文件中，并存档在当前的作业（Job）中。下游的作业（Job）可以通过这个插件从触发它的上游作业（Job）拷贝这个状态数据文件，加载成环境变量，从而实现状态的恢复。</p>
</li>
<li><p>EnvInject Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin</a></p>
<p>利用这个插件可以将流水线的以key-value值的方式存储的状态文件加载为当前阶段（Phase）当前任务（Task）的环境变量。</p>
<blockquote>
<p>注意，key的名字不要包含中划线，否则Jenkins 作业（Job）不识别。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以上五个插件是实现CI/CD流水线必需的插件，装这四个插件可能还会自动安装一些依赖的插件。</p>
</blockquote>
<ul>
<li><p>Description Setter Plugin<br><a href="http://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin" target="_blank" rel="noopener">http://wiki.jenkins-ci.org/display/JENKINS/Description+Setter+Plugin</a></p>
<p>这个插件比较简单了，主要是用来设置Job(Task)的描述，这样在CI/CD流水线中能显示更多的信息。</p>
</li>
<li><p>Flexible Publish Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Flexible+Publish+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Flexible+Publish+Plugin</a></p>
<p>这个插件主要是用来实现作业（Job）中的步骤（step）的控制流，扩展了Jenkins 作业（Job）的步骤（steps）只能顺序执行的方式。</p>
</li>
<li><p>Email-ext Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin</a></p>
<p>扩展的邮件插件，能够定制复杂的邮件内容。邮件通知是一个成熟的CI/CD流水线必要的特征。</p>
</li>
<li><p>Token Macro Plugin<br><a href="https://wiki.jenkins.io/display/JENKINS/Token+Macro+Plugin" target="_blank" rel="noopener">https://wiki.jenkins.io/display/JENKINS/Token+Macro+Plugin</a></p>
<p>在作业（Job）的描述或通知邮件的内容中可以通过引用Jenkins当前构建（build）的环境变量实现描述或邮件内容的模板化。Token Macro插件则负责在运行时解析这些变量引用。</p>
</li>
</ul>
</li>
</ol>
<h2 id="Jenkins-Job配置"><a href="#Jenkins-Job配置" class="headerlink" title="Jenkins Job配置"></a>Jenkins Job配置</h2><p>为了实现这个CI/CD流水线，下图是一个Jenkins Job所需的步骤，但并不是所有的Job都需要实现所有的步骤。比如Build/UT阶段（Phase）的Build任务（Task）是整个流水线的第一个Jenkins作业（Job），所以不需要步骤3去拷贝流水线状态文件，也不需要步骤4去加载状态文件，而最后一个Smoke Test任务（Task）也不要步骤2去提升（Promote）到下一个阶段（Phase）或者任务（Task）。</p>
<div align="center">
<img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/4.png">
</div>

<p>步骤的一些说明：</p>
<ol>
<li><p>配置“Delivery Pipeline”节。“Stage Name”是阶段（Phase）名，“Task Name”是这个Jenkins Job在这个阶段（Phase）中的任务（Task）名字；</p>
</li>
<li><p>Jenkins作业（Job）提升（Promotion）的配置。在“Criteria”下选择提升（Promotion）的策略，在“Actions”中选择待触发的下游Jenkins作业（Job）；</p>
</li>
<li><p>从上游作业（Job）拷贝流水线状态文件；</p>
</li>
<li><p>将状态文件加载为当前作业（Job）的环境变量。</p>
</li>
</ol>
<h2 id="如何提升（Promote）阶段（Phase）或任务（Task）"><a href="#如何提升（Promote）阶段（Phase）或任务（Task）" class="headerlink" title="如何提升（Promote）阶段（Phase）或任务（Task）"></a>如何提升（Promote）阶段（Phase）或任务（Task）</h2><p>下图展示了如何提升（Promote）阶段（Phase）或任务（Task），也就是Jenkins作业（Job）：</p>
<div align="center">
<img src="/2018/10/07/jenkins-freestyle-cicd-pipeline/5.png">
</div>

<p>步骤的一些说明：</p>
<ol>
<li><p>在当前的流水线实例中打开上游作业（Job）的构建（Build）页面，点击左侧链接“Promotions Status”；</p>
</li>
<li><p>只有在“Approvers”列表里的用户有权手动批准提升（Promotion）；</p>
</li>
<li><p>点击“Approve”按钮触发提升（Promotion）；</p>
</li>
<li><p>Jenkins管理员有权限强制提升（Promotion）；</p>
</li>
<li><p>通过点击“Re-execute promotion”可重复提升（Promote）当前的作业（Job）。</p>
</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>每一种方法有它的优点，必定也有它的缺点，没有一种方法是银弹，可以解决一切问题，打败天下无敌手。是否使用它，就要自己去权衡：是它的优点给你带来了更多，还是它的缺点是当前的最大障碍。这种方法的缺点大致如下：</p>
<ol>
<li><p>仅管“Delivery Pipeline Plugin”可以图形化显示Jenkins Pipeline 2.0（Jenkinsfile）作业（Job）的上下游调用关系，但是“Promotes Builds Plugin”不支持Jenkins Pipeline 2.0（Jenkinsfile），所以太多的Freestyle Job要去创建，设置和维护，这些Job只能作为配置存储在Jenkins Master服务器上，而不能作为代码存储在Git中；</p>
</li>
<li><p>会多占用一些Slave节点的线程，因为作业（Job）的提升其实也是作业（Job）需要占用一个Slave线程。</p>
</li>
</ol>
<p>期待“Promotes Builds Plugin”能够支持Jenkins Pipeline 2.0 （Jenkinfile），这样所有的任务（Task）也就是Jenkins作业（Job）全部可以作为代码存储在Git中，而且维护起来也很方便。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Jenkins随笔(5) Jenkins构建GitLab合并请求(Merge Request)</title>
    <url>/2020/03/09/jenkins-gitlab-pullrequest/</url>
    <content><![CDATA[<p>写了两篇这样的文章，我们大概可以总结出Jenkins构建合并请求(Merge Request)的原理：首先，需要在Jenkins上安装一个插件以便提供一个Webhook接口，配置插件连通对应的代码协作平台以便将构建状态写回代码协作平台(并不是所有的插件都提供这个功能)；其次，在对应的Git仓库中设置Webhook监听Git事件，比如合并请求(Merge Request)的创建、编辑等。当有监听的事件发生时，Webhook触发Jenkins的Webhook接口，Webhook接口解析请求数据，创建一些有用的环境变量，比如合并请求(Merge Request)ID，合并请求(Merge Request)的原分支和目标分支等，并触发对应的Jenkins pipeline；最后，创建一个Jenkins pipeline(目前主要是Pipeline2.0的Jenkinsfile)，设置被触发的条件和如何克隆对应的代码，以及实际的构建逻辑。接前面的系列，本文将继续介绍如何配置Jenkins和GitLab来构建GitLab合并请求(Merge Request)。</p>
<a id="more"></a>

<p>GitLab<a href="https://docs.gitlab.com/ee/integration/jenkins.html" target="_blank" rel="noopener">官方文档</a>有写到用Jenkins去构建GitLab中的代码，但是用到了”Jenkins CI”这个项目服务，而这个服务在GitLab免费版本(社区版)中并没有提供，所以不去过多的讨论此方法。下面将利用Jenkins的<a href="https://plugins.jenkins.io/git/" target="_blank" rel="noopener">Git插件</a>和<a href="https://plugins.jenkins.io/gitlab-plugin/" target="_blank" rel="noopener">GitLab插件</a>去实现Jenkins构建GitLab的合并请求(Merge Request)。</p>
<h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装GitLab插件-如果Git插件不存在，会作为GitLab插件的依赖被安装"><a href="#安装GitLab插件-如果Git插件不存在，会作为GitLab插件的依赖被安装" class="headerlink" title="安装GitLab插件(如果Git插件不存在，会作为GitLab插件的依赖被安装)"></a>安装GitLab插件(如果Git插件不存在，会作为GitLab插件的依赖被安装)</h2><ol>
<li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p>
</li>
<li><p>打开Available页面，选择GitLab插件，点击Install without restart按钮</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/1.png">
</div>
</li>
<li><p>必要时重启Jenkins让插件生效</p>
</li>
</ol>
<p>安装完插件后，生成的Web hook url地址为<code>https://JENKINS_URL/project/YOUR_JOB</code>。</p>
<h2 id="创建Gitlab-Personal-Access-Token"><a href="#创建Gitlab-Personal-Access-Token" class="headerlink" title="创建Gitlab Personal Access Token"></a>创建Gitlab Personal Access Token</h2><ol>
<li><p>点击Settings打开用户设置页面，并点击Access Tokens打开创建Personal Access Token页面</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/3.png">
</div>
</li>
<li><p>在Name字段填上Token的名字，在Scope字段选上需要的权限，api的权限应该足够了。如果需要设置有效期限，可以设置Expires at字段，否则Token永不过期</p>
</li>
<li><p>点击Create personal access token按钮创建Token。注意，需要立即复制这个Token值，否则页面刷新后就会被隐藏掉</p>
</li>
</ol>
<h2 id="配置Jenkins-Gitlab插件"><a href="#配置Jenkins-Gitlab插件" class="headerlink" title="配置Jenkins Gitlab插件"></a>配置Jenkins Gitlab插件</h2><ol>
<li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Config System打开系统配置页面</p>
</li>
<li><p>定位到”GitLab“段落，点击Add菜单打开创建Jenkins认证信息对话框</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/2.png">
</div>
</li>
<li><p>选择”GitLab API Token”类型的凭证，在API token字段里输入前面创建的Gitlab Personal Access Token，设置Token的ID和描述</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/4.png">
</div>
</li>
<li><p>设置Gitlab详细的连接信息</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/5.png">
</div>
设置Connection name，Gitlab host URL，选择刚刚创建的GitLab API Token，连接和读取超时可以稍微设大一点。可以点击Test Connection测试是否能连通。
</li>
<li><p>点击”Save”按钮保存配置</p>
</li>
</ol>
<h1 id="创建Jenkins-pipeline-job用来构建合并请求-Merge-Request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-Merge-Request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(Merge Request)"></a>创建Jenkins pipeline job用来构建合并请求(Merge Request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">'common'</span></span><br><span class="line">    &#125;</span><br><span class="line">    triggers &#123;</span><br><span class="line">        gitlab(</span><br><span class="line"><span class="symbol">            triggerOnPush:</span> <span class="literal">false</span>,</span><br><span class="line"><span class="symbol">            triggerOnMergeRequest:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            triggerOpenMergeRequestOnPush:</span> <span class="string">"source"</span>,</span><br><span class="line"><span class="symbol">            triggerOnNoteRequest:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            noteRegex:</span> <span class="string">".*\\[run\\W+ci\\].*"</span>,</span><br><span class="line"><span class="symbol">            skipWorkInProgressMergeRequest:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            ciSkip:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            setBuildDescription:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            addNoteOnMergeRequest:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            addCiMessage:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            addVoteOnMergeRequest:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">            acceptMergeRequestOnSuccess:</span> <span class="literal">false</span>,</span><br><span class="line"><span class="symbol">            branchFilterType:</span> <span class="string">"NameBasedFilter"</span>,</span><br><span class="line"><span class="symbol">            includeBranchesSpec:</span> <span class="string">"master"</span>,</span><br><span class="line"><span class="symbol">            excludeBranchesSpec:</span> <span class="string">""</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        GITLAB_URL = <span class="string">"http://mygitlab.philips.com"</span></span><br><span class="line">        GITLAB_ORG = <span class="string">"mikesay"</span></span><br><span class="line">        GITLAB_REPO = <span class="string">"mikesay-test-1"</span></span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout()</span><br><span class="line">        ansiColor(<span class="string">'xterm'</span>)</span><br><span class="line">        gitLabConnection <span class="string">'mygitlab'</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Checkout'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                    <span class="keyword">def</span> scmVars =   checkout(</span><br><span class="line">                                        [<span class="string">$class:</span> <span class="string">'GitSCM'</span>, <span class="string">branches:</span> [[<span class="string">name:</span> <span class="string">"origin/mr/$&#123;gitlabMergeRequestId&#125;/head"</span>]], </span><br><span class="line"><span class="symbol">                                        doGenerateSubmoduleConfigurations:</span> <span class="literal">false</span>,</span><br><span class="line"><span class="symbol">                                        submoduleCfg:</span> [], </span><br><span class="line"><span class="symbol">                                        extensions:</span> [</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'RelativeTargetDirectory'</span>, <span class="string">relativeTargetDir:</span> <span class="string">'codes'</span>],</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'CleanBeforeCheckout'</span>]</span><br><span class="line">                                        ],</span><br><span class="line"><span class="symbol">                                        userRemoteConfigs:</span> [</span><br><span class="line">                                                [</span><br><span class="line"><span class="symbol">                                                    credentialsId:</span> <span class="string">'gitlab_account'</span>, </span><br><span class="line"><span class="symbol">                                                    name:</span> <span class="string">'origin'</span>, </span><br><span class="line"><span class="symbol">                                                    refspec:</span> <span class="string">'+refs/heads/*:refs/remotes/origin/* +refs/merge-requests/*:refs/remotes/origin/mr/*'</span>, </span><br><span class="line"><span class="symbol">                                                    url:</span> <span class="string">"$&#123;GITLAB_URL&#125;/$&#123;GITLAB_ORG&#125;/$&#123;GITLAB_REPO&#125;.git"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                            ]</span><br><span class="line">                                        ]</span><br><span class="line">                                    )</span><br><span class="line">                    env.GIT_BRANCH = <span class="string">"$&#123;scmVars.GIT_BRANCH&#125;"</span></span><br><span class="line">                    env.GIT_COMMIT = <span class="string">"$&#123;scmVars.GIT_COMMIT&#125;"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                dir(<span class="string">'codes'</span>) &#123;</span><br><span class="line">                    sh <span class="string">'''#!/bin/bash -l</span></span><br><span class="line"><span class="string">                        echo "Start building!"</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">      failure &#123;</span><br><span class="line">        updateGitlabCommitStatus <span class="string">name:</span> <span class="string">'build'</span>, <span class="string">state:</span> <span class="string">'failed'</span></span><br><span class="line">      &#125;</span><br><span class="line">      success &#123;</span><br><span class="line">        updateGitlabCommitStatus <span class="string">name:</span> <span class="string">'build'</span>, <span class="string">state:</span> <span class="string">'success'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>6行-22行设置GitLab触发器，主要设置如下：</li>
</ol>
<table>
<thead>
<tr>
<th>变量</th>
<th>事例值</th>
</tr>
</thead>
<tbody><tr>
<td>triggerOnPush</td>
<td>任何推送事件都会触发构建。因为是用来构建合并请求(Merge Request)，只需要监听合并请求(Merge Request)事件，所以不需要打开。</td>
</tr>
<tr>
<td>triggerOnMergeRequest</td>
<td>设置合并请求(Merge Request)事件触发构建，需要打开。</td>
</tr>
<tr>
<td>triggerOpenMergeRequestOnPush</td>
<td>当合并请求(Merge Request)的原分支有新的推送触发构建，需要打开。</td>
</tr>
<tr>
<td>triggerOnNoteRequest</td>
<td>合并请求(Merge Request)的评论有更新时触发构建，需要打开，并且配合noteRegex设置具体的触发构建的字符串。</td>
</tr>
<tr>
<td>ciSkip</td>
<td>当合并请求(Merge Request)的评论包括字符串”[ci-skip]”时，不会构建这个合并请求(Merge Request)。</td>
</tr>
<tr>
<td>branchFilterType, includeBranchesSpec, excludeBranchesSpec</td>
<td>设置哪些分支上的合并请求(Merge Request)会触发构建。</td>
</tr>
</tbody></table>
<ol start="2">
<li><p>50行: 添加refspec获取合并请求(merge request)的分支信息</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">refspec:</span> <span class="string">'+refs/merge-requests/*:refs/remotes/origin/mr/*'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>39行: branches选择”origin/mr/${gitlabMergeRequestId}/head”, 是合并后的分支。环境变量”gitlabMergeRequestId”是合并请求(merge request)的ID号</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[<span class="string">$class:</span> <span class="string">'GitSCM'</span>, <span class="string">branches:</span> [[<span class="string">name:</span> <span class="string">"origin/mr/$&#123;gitlabMergeRequestId&#125;/head"</span>]]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>除了”gitlabMergeRequestId”外，Gitlab插件还往当前构建中注入了许多变量供构建Job使用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gitlabBranch</span><br><span class="line">gitlabSourceBranch</span><br><span class="line">gitlabActionType</span><br><span class="line">gitlabUserName</span><br><span class="line">gitlabUserUsername</span><br><span class="line">gitlabUserEmail</span><br><span class="line">gitlabSourceRepoHomepage</span><br><span class="line">gitlabSourceRepoName</span><br><span class="line">gitlabSourceNamespace</span><br><span class="line">gitlabSourceRepoURL</span><br><span class="line">gitlabSourceRepoSshUrl</span><br><span class="line">gitlabSourceRepoHttpUrl</span><br><span class="line">gitlabMergeRequestTitle</span><br><span class="line">gitlabMergeRequestDescription</span><br><span class="line">gitlabMergeRequestId</span><br><span class="line">gitlabMergeRequestIid</span><br><span class="line">gitlabMergeRequestState</span><br><span class="line">gitlabMergedByUser</span><br><span class="line">gitlabMergeRequestAssignee</span><br><span class="line">gitlabMergeRequestLastCommit</span><br><span class="line">gitlabMergeRequestTargetProjectId</span><br><span class="line">gitlabTargetBranch</span><br><span class="line">gitlabTargetRepoName</span><br><span class="line">gitlabTargetNamespace</span><br><span class="line">gitlabTargetRepoSshUrl</span><br><span class="line">gitlabTargetRepoHttpUrl</span><br><span class="line">gitlabBefore</span><br><span class="line">gitlabAfter</span><br><span class="line">gitlabTriggerPhrase</span><br></pre></td></tr></table></figure>

<h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol>
<li><p>点击”New Item”</p>
</li>
<li><p>选择Job类型为”Pipeline”，输入Job的名字，比如”gitlab-preflight”，点击”Ok”按钮</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/6.png">
</div>
</li>
<li><p>在”Pipeline”段，引用Jenkinsfile(Jenkinsfile是单独放在一个独立的Git仓库中的)</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/7.png">
</div>
</li>
<li><p>点击”Save”按钮保存Jenkins Job</p>
</li>
<li><p>手动触发Job一次让Jenkinsfile中设置的触发规则配置到job中。</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/8.png">
</div>

</li>
</ol>
<h1 id="配置Gitlab"><a href="#配置Gitlab" class="headerlink" title="配置Gitlab"></a>配置Gitlab</h1><h2 id="创建Jenkins-API-token"><a href="#创建Jenkins-API-token" class="headerlink" title="创建Jenkins API token"></a>创建Jenkins API token</h2><ol>
<li><p>进入Jenkins用户设置页面</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/11.png">
</div>
</li>
<li><p>点击Add new Token，并点击Generate按钮产生当前用户的API Token，注意立即复制保存，因为页面刷新后，将被隐藏</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/12.png">
</div>
</li>
<li><p>点击Save按钮保存</p>
</li>
</ol>
<h2 id="创建Gitlab-Web-hook"><a href="#创建Gitlab-Web-hook" class="headerlink" title="创建Gitlab Web hook"></a>创建Gitlab Web hook</h2><ol>
<li><p>进入具体的项目页面，点击Settings -&gt; Integrations打开创建Web hook的页面</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/13.png">
</div>
</li>
<li><p>设置Web hook详细信息</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/14.png">
</div>
在URL地址里输入Jenkins Gitlab插件生成的Web hook地址，包括Jenkins的认证信息，比如```https://<jenkins user>:<user's api token>@mykube.com/jenkins/project/gitlab-preflight```，选择"Comments"和"Merge request events"用来监听合并请求(merge request)事件，包括评论更新事件。
</user's></jenkins></li>
<li><p>点击Add webhook按钮添加Web hook</p>
</li>
</ol>
<h1 id="创建合并请求-merge-request-触发构建"><a href="#创建合并请求-merge-request-触发构建" class="headerlink" title="创建合并请求(merge request)触发构建"></a>创建合并请求(merge request)触发构建</h1><ol>
<li><p>Gitlab的合并请求(merge request)</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/9.png">
</div>
</li>
<li><p>触发的构建</p>
<div align="center">
<img src="/2020/03/09/jenkins-gitlab-pullrequest/10.png">
</div>

</li>
</ol>
<p>从构建的描述来看，Jenkins Gitlab插件提供了比较全面的功能，显示了合并请求(merge request)的信息，同时在Gitlab的合并请求(merge request)页面也显示了构建的信息。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Git</tag>
        <tag>Jenkins</tag>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Jenkins随笔(3) Jenkins构建Github合并请求(Pull Request)</title>
    <url>/2020/01/30/jenkins-github-pullrequest/</url>
    <content><![CDATA[<p>在我的文章<a href="http://www.mikesay.com/2020/01/29/pullrequest-essential/">“Git合并请求(pull/merge request)的本质”</a>中已经说明了合并请求(pull/merge request)在代码层面上实际是Git仓库中的一个特殊分支，它指向了私有分支和主分支临时合并后产生的合并提交(merge commit)。如果我们能够在这个合并请求(pull/merge request)被真正合并进主分支之前对它做一次构建，就能尽早发现私有分支上的代码是否有问题，从而将问题拦截在主分支之外，减少主分支上持续交付流水线的失败率。对合并请求(pull/merge request)的构建除了编译代码(必要时可增量编译)和单元测试外，还可以增加更多额外的检查，比如代码的静态扫描。业界把这个放在持续交付流水线之前的检查称为preflight流水线(可参考《Continuous Delivery》这本书第三章67页对preflight构建的详细介绍)。本文将介绍如何配置Jenkins和Github来构建Github合并请求(Pull Request)。</p>
<a id="more"></a>

<h1 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h1><h2 id="安装Github-Pull-Request-Builder插件"><a href="#安装Github-Pull-Request-Builder插件" class="headerlink" title="安装Github Pull Request Builder插件"></a>安装Github Pull Request Builder插件</h2><ol>
<li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Manage Plugins打开Plugin Manager页面</p>
</li>
<li><p>打开Available页面，选择Github Pull Request Builder，点击Install without restart按钮</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/1.png">
</div>
</li>
<li><p>必要时重启Jenkins让插件生效</p>
</li>
</ol>
<h2 id="配置Github-Pull-Request-Builder插件"><a href="#配置Github-Pull-Request-Builder插件" class="headerlink" title="配置Github Pull Request Builder插件"></a>配置Github Pull Request Builder插件</h2><ol>
<li><p>点击Jenkins -&gt; Manage Jenkins -&gt; Config System打开系统配置页面</p>
</li>
<li><p>定位到”Github Pull Request Builder“插件，点击Add菜单打开创建Jenkins认证信息对话框</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/2.png">
</div>
</li>
<li><p>创建”Username with password”类型的凭证，用户名和密码是有足够权限的Github账号和密码</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/3.png">
</div>
</li>
<li><p>配置GitHub Server API URL，选择步骤3创建的凭证，可以点击”Connect to API”按钮测试基本连接</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/4.png">
</div>

<p>对于GitHub Server API URL的值，GitHub和GitHub Enterprise是有区别的：</p>
</li>
</ol>
<p>| GitHub Server     | API Endpoint                | 说明                                    |<br>| —————– | ————————— |<br>| GitHub Enterprise | http(s)://[hostname]/api/v3 |                                         |<br>| GitHub            | <a href="https://api.github.com" target="_blank" rel="noopener">https://api.github.com</a>      | Receive the v3 version of the REST API. |</p>
<ol start="5">
<li>点击”Save”按钮保存配置</li>
</ol>
<h1 id="配置Github代码仓库"><a href="#配置Github代码仓库" class="headerlink" title="配置Github代码仓库"></a>配置Github代码仓库</h1><ol>
<li><p>打开Git仓库设置页面，点击Hooks -&gt; Add webhook</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/5.png">
</div>
</li>
<li><p>输入Palyload URL(<code>http://jenkins-url/github-webhook/</code>)，选择Content Type为application/json</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/6.png">
</div>
</li>
<li><p>选择”Let me select individual envents”自定义webhook触发事件</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/7.png">
</div>
</li>
<li><p>只选择”Pull requests”事件，并点击”Add webhook”保存Webhook</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/8.png">
</div>

</li>
</ol>
<h1 id="创建Jenkins-pipeline-job用来构建合并请求-pull-merge-request"><a href="#创建Jenkins-pipeline-job用来构建合并请求-pull-merge-request" class="headerlink" title="创建Jenkins pipeline job用来构建合并请求(pull/merge request)"></a>创建Jenkins pipeline job用来构建合并请求(pull/merge request)</h1><h2 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent &#123;</span><br><span class="line">        label <span class="string">'common'</span></span><br><span class="line">    &#125;</span><br><span class="line">    environment &#123;</span><br><span class="line">        GITHUB_URL = <span class="string">"http://xxx.github.xxxx.com"</span></span><br><span class="line">        GITHUB_ORG = <span class="string">"MikeSay"</span></span><br><span class="line">        GITHUB_REPO = <span class="string">"mikesay-test-1"</span></span><br><span class="line">    &#125;</span><br><span class="line">    options &#123;</span><br><span class="line">        skipDefaultCheckout()</span><br><span class="line">        ansiColor(<span class="string">'xterm'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(<span class="string">'Checkout'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                script&#123;</span><br><span class="line">                    <span class="keyword">def</span> scmVars =   checkout(</span><br><span class="line">                                        [<span class="string">$class:</span> <span class="string">'GitSCM'</span>, <span class="string">branches:</span> [[<span class="string">name:</span> <span class="string">"$&#123;ghprbActualCommit&#125;"</span>]], </span><br><span class="line"><span class="symbol">                                        doGenerateSubmoduleConfigurations:</span> <span class="literal">false</span>,</span><br><span class="line"><span class="symbol">                                        submoduleCfg:</span> [], </span><br><span class="line"><span class="symbol">                                        extensions:</span> [</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'RelativeTargetDirectory'</span>, <span class="string">relativeTargetDir:</span> <span class="string">'codes'</span>],</span><br><span class="line">                                            [<span class="string">$class:</span> <span class="string">'CleanBeforeCheckout'</span>]</span><br><span class="line">                                        ],</span><br><span class="line"><span class="symbol">                                        userRemoteConfigs:</span> [</span><br><span class="line">                                                [</span><br><span class="line"><span class="symbol">                                                    credentialsId:</span> <span class="string">'ghe_account'</span>, </span><br><span class="line"><span class="symbol">                                                    name:</span> <span class="string">'origin'</span>, </span><br><span class="line"><span class="symbol">                                                    refspec:</span> <span class="string">'+refs/pull/*:refs/remotes/origin/pr/*'</span>, </span><br><span class="line"><span class="symbol">                                                    url:</span> <span class="string">"$&#123;GITHUB_URL&#125;/$&#123;GITHUB_ORG&#125;/$&#123;GITHUB_REPO&#125;.git"</span></span><br><span class="line">                                                ]</span><br><span class="line">                                            ]</span><br><span class="line">                                        ]</span><br><span class="line">                                    )</span><br><span class="line">                    env.GIT_BRANCH = <span class="string">"$&#123;scmVars.GIT_BRANCH&#125;"</span></span><br><span class="line">                    env.GIT_COMMIT = <span class="string">"$&#123;scmVars.GIT_COMMIT&#125;"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">'Build'</span>) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                dir(<span class="string">'codes'</span>) &#123;</span><br><span class="line">                    sh <span class="string">'''#!/bin/bash -l</span></span><br><span class="line"><span class="string">                        echo "Start building!"</span></span><br><span class="line"><span class="string">                        cat README.md</span></span><br><span class="line"><span class="string">                    '''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    post &#123;</span><br><span class="line">        always &#123;</span><br><span class="line">            junit <span class="string">allowEmptyResults:</span> <span class="literal">true</span>, <span class="string">testResults:</span> <span class="string">'codes/build/test-results/test/**/*.xml'</span></span><br><span class="line">            <span class="comment">// send to email</span></span><br><span class="line">            emailext(</span><br><span class="line"><span class="symbol">                subject:</span> <span class="string">'$DEFAULT_SUBJECT'</span>,</span><br><span class="line"><span class="symbol">                body:</span> <span class="string">'$DEFAULT_CONTENT'</span>,</span><br><span class="line"><span class="symbol">                recipientProviders:</span> [</span><br><span class="line">                [<span class="string">$class:</span> <span class="string">'CulpritsRecipientProvider'</span>],</span><br><span class="line">                [<span class="string">$class:</span> <span class="string">'RequesterRecipientProvider'</span>],</span><br><span class="line">                [<span class="string">$class :</span> <span class="string">'DevelopersRecipientProvider'</span>]</span><br><span class="line">                ],</span><br><span class="line"><span class="symbol">                replyTo:</span> <span class="string">'$DEFAULT_REPLYTO'</span>,</span><br><span class="line"><span class="symbol">                to:</span> <span class="string">'$DEFAULT_RECIPIENTS'</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>30行: 添加refspec获取合并请求(pull/merge request)的分支信息</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">refspec:</span> <span class="string">'+refs/pull/*:refs/remotes/origin/pr/*'</span></span><br></pre></td></tr></table></figure>

<p>19行: branches选择环境变量”ghprbActualCommit”，它是合并请求(pull/merge request)分支对应的提交号</p>
<pre><code class="groovy">[<span class="string">$class:</span> <span class="string">'GitSCM'</span>, <span class="string">branches:</span> [[<span class="string">name:</span> <span class="string">"${ghprbActualCommit}"</span>]]</code></pre>
<p>除了”ghprbActualCommit”外，github pull request builder插件还往当前构建中注入了许多变量供构建Job使用，如下表：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>事例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sha1</td>
<td>origin/pr/6/merge</td>
<td>合并请求(pull/merge request)分支。在构建Job中也可以用${sha1}来代替${ghprbActualCommit}</td>
</tr>
<tr>
<td>ghprbAuthorRepoGitUrl</td>
<td><a href="http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1.git" target="_blank" rel="noopener">http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1.git</a></td>
<td>合并请求(pull/merge request)所在仓库的http地址</td>
</tr>
<tr>
<td>ghprbPullId</td>
<td>6</td>
<td>合并请求(pull/merge request)的ID号</td>
</tr>
<tr>
<td>ghprbTargetBranch</td>
<td>master</td>
<td>合并请求(pull/merge request)的主分支</td>
</tr>
<tr>
<td>ghprbSourceBranch</td>
<td>test9</td>
<td>合并请求(pull/merge request)的私有分支</td>
</tr>
<tr>
<td>ghprbPullTitle</td>
<td>Test9.</td>
<td>合并请求(pull/merge request)的标题</td>
</tr>
<tr>
<td>ghprbPullLink</td>
<td><a href="http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1/pull/6" target="_blank" rel="noopener">http://xxxx.github.xxxx.com/MikeSay/mikesay-test-1/pull/6</a></td>
<td>合并请求(pull/merge request)的http地址</td>
</tr>
</tbody></table>
<p>可以从当前合并请求(pull/merge request)的构建参数中获得所有变量名和当前值：</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/16.png">
</div>

<h2 id="创建Jenkins-job引用Jenkinsfile"><a href="#创建Jenkins-job引用Jenkinsfile" class="headerlink" title="创建Jenkins job引用Jenkinsfile"></a>创建Jenkins job引用Jenkinsfile</h2><ol>
<li><p>点击”New Item”</p>
</li>
<li><p>选择Job类型为”Pipeline”，输入Job的名字”github-preflight”，点击”Ok”按钮</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/9.png">
</div>
</li>
<li><p>在”GitHub Project”段，输入”Project url”。注，”Project url”是Git仓库的http地址去除”.git”后缀</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/10.png">
</div>
</li>
<li><p>在”Build Triggers”段，选择”GitHub Pull Request Builder”</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/11.png">
</div>

<ul>
<li>GitHub API credentials: 之前配置的GitHub API</li>
<li>Trigger phrase: 在合并请求(pull/merge request)的注释或标题里加入trigger phrase内容会自动触发新的构建</li>
<li>Skip build phrase: 在合并请求(pull/merge request)的注释或标题里加入skip build phrase内容则不会触发构建</li>
</ul>
</li>
<li><p>如果需要构建每个合并请求(pull/merge request)，勾选”Build every pull request automatically without asking (Dangerous)”，在”Whitelist Target Branches”输入主分支”master”</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/12.png">
</div>
</li>
<li><p>在”Pipeline”段，引用Jenkinsfile</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/13.png">
</div>

</li>
</ol>
<h1 id="创建合并请求-pull-merge-request-触发构建"><a href="#创建合并请求-pull-merge-request-触发构建" class="headerlink" title="创建合并请求(pull/merge request)触发构建"></a>创建合并请求(pull/merge request)触发构建</h1><ol>
<li><p>Github的合并请求(pull/merge request)</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/14.png">
</div>
</li>
<li><p>触发的构建</p>
<div align="center">
<img src="/2020/01/30/jenkins-github-pullrequest/15.png">
</div>

</li>
</ol>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】Hexo+Gitee(码云)搭建静态博客网站</title>
    <url>/2018/08/17/setup-blog-hexo-gitee/</url>
    <content><![CDATA[<p>直接注册和使用当下比较流行的博客网站比如csdn, oschina, 博客园等等，觉得不是自己专属，而且还有很多广告。选择一款开源或免费的CMS(内容管理系统)，自己买云主机和域名搭建博客，费钱又费时。有时我们只是希望有一个功能不太复杂，自己专属的或者看起来自己专属的（至少没有一堆广告）博客网站来写写和分享自己的文章。不需要花费太多的时间和钱，除非你的博客和文章已经足够热门。基于以上的期望，本文将介绍如何使用Hexo搭建静态博客网站，并将其发布到GITEE(码云)免费提供的静态网页空间里。</p>
<a id="more"></a>

<h1 id="Hexo是什么"><a href="#Hexo是什么" class="headerlink" title="Hexo是什么"></a>Hexo是什么</h1><p>Hexo是一款免费的用来快速搭建静态博客网站的框架。支持插件机制，简单又不失强大。Hexo是基于Node.js开发的，提供了一组命令用来创建和管理博客应用，创建和管理博客文章，将博客应用和文章发布成静态博客网站。Hexo使用Markdown语言来写博客，方便、快捷，不需要什么额外的排版工具就能使你的文章布局看起来很美观。下图是Hexo博客网站的结构：</p>
<div align="center">
<img src="/2018/08/17/setup-blog-hexo-gitee/1.png" title="Hexo博客网站结构">
</div>

<h1 id="Gitee是什么"><a href="#Gitee是什么" class="headerlink" title="Gitee是什么"></a>Gitee是什么</h1><p>Gitee（码云 <a href="https://gitee.com/" target="_blank" rel="noopener">gitee.com</a>）是国内的一款基于Git的代码托管和协作开发平台，和GitHub, GitLab属于同一类型的产品。同GitHub和GitLab相比，Gitee具有以下几点优势：</p>
<ul>
<li>支持免费的私有Git代码仓库</li>
<li>在国内，不需要科学上网，访问速度快  </li>
</ul>
<p>Gitee平台也提供了免费的静态页面托管服务“码云Pages”，可以用来托管博客，项目官网等静态网页。“码云Pages Pro”是这个服务的高阶收费版，支持发布代码仓库中的某个目录，支持自定义域名。</p>
<blockquote>
<p>要详细了解Gitee的概念和使用，可以参考Gitee的官方在线帮助文档：<a href="https://gitee.com/help" target="_blank" rel="noopener">https://gitee.com/help</a></p>
</blockquote>
<p>本文将会在Gitee上创建Git代码仓库管理Hexo博客应用的代码和静态博客网站，同时将静态博客网页托管到“码云Pages”。</p>
<h1 id="从零开始搭建专属博客"><a href="#从零开始搭建专属博客" class="headerlink" title="从零开始搭建专属博客"></a>从零开始搭建专属博客</h1><p>介绍完Hexo和Gitee后，明白了它们的概念和用途。下面我们就从零开始完整地搭建一个自己专属的博客。</p>
<h2 id="安装必备的软件"><a href="#安装必备的软件" class="headerlink" title="安装必备的软件"></a>安装必备的软件</h2><ul>
<li>安装Node.js<ul>
<li>Mac上安装</li>
<li>Linux上安装</li>
<li>Windows上安装</li>
</ul>
</li>
<li>安装Git客户端<ul>
<li>Mac上安装</li>
<li>Linux上安装</li>
<li>Windows上安装</li>
</ul>
</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>运行以下命令安装Hexo（Hexo命令行）到Node.js的全局空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Hexo是用Node.js开发的，所以它以npm包格式发布。</p>
</blockquote>
<h2 id="创建一个新的博客应用"><a href="#创建一个新的博客应用" class="headerlink" title="创建一个新的博客应用"></a>创建一个新的博客应用</h2><ol>
<li><p>依次执行以下shell命令创建一个缺省的博客应用：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexo-test-blog</span><br><span class="line"><span class="built_in">cd</span> hexo-test-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>博客应用的文件结构：<br>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>│   ├── draft.md<br>│   ├── page.md<br>│   └── post.md<br>├── source<br>│   └── _posts<br>│   └── _drafts<br>└── themes<br>│   └── landscape  </p>
<ul>
<li>_config.yml<br>博客站点配置文件。</li>
<li>package.json<br>博客应用引用的第三方Node.js包。</li>
<li>scaffolds<br>脚手架是用来快速创建博客页面的模板。有三类模板，“文章”，“草稿”和“页面”。脚手架不是最终博客页面显示的模板，显示是由当前主题的layout文件夹中的模板负责。</li>
<li>source<br>博客文章的存放目录。分为“_posts”和“_drafts”两个子目录，分别存放正式文章和草稿文章。</li>
<li>themes<br>Hexo博客的主题。缺省安装的主题是“landscape”。</li>
</ul>
</blockquote>
</li>
<li><p>执行以下命令构建博客应用，生成静态博客网站</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm intall</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令启动一个本地http服务查看静态博客网站  </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在浏览器中输入http<nolink>://localhost:4000打开博客网站。</nolink></p>
</blockquote>
</li>
<li><p>设置一些“应用配置”(_config.yml)</p>
<blockquote>
<p>这里将根目录下的配置文件”_config.yml“称为”应用配置“以便与后面的“主题配置”区分看来。”主题配置“是位于博客应用的主题根目录下的配置文件，名字也是”_config.yml“。</p>
</blockquote>
<ul>
<li>title: 若一拾得</li>
<li>subtitle: 若一不一，知之不知</li>
<li>description:</li>
<li>keywords: DevOps, Infrastructure As Code(IAC), CI/CD, Operation, Monitor, Python</li>
<li>author: 若一</li>
<li>language: zh-Hans</li>
<li>timezone: Asia/Shanghai</li>
<li>url: <a href="http://www.ruokiy.com" target="_blank" rel="noopener">http://www.ruokiy.com</a></li>
<li>root: /</li>
<li>permalink: :year/:month/:day/:title/ =&gt; 文章页面的永久链接</li>
<li>permalink_defaults:</li>
</ul>
</li>
</ol>
<blockquote>
<p>可以参考Hexo的官方文档了解更多的Hexo命令。</p>
</blockquote>
<h2 id="为博客应用安装新的主题"><a href="#为博客应用安装新的主题" class="headerlink" title="为博客应用安装新的主题"></a>为博客应用安装新的主题</h2><p>Hexo自带的主题“landscape”看起来平平，不够简洁也不够富丽，所以大部分人安装和初始化完Hexo博客应用后，接下来的一步就是安装配置自己喜欢的主题。下面就以以简洁著称的“NexT”主题为例，介绍安装和配置主题的步骤。</p>
<p>“NexT”主题在GitHub上，地址为<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a>。</p>
<blockquote>
<p>注意：GitHub上还有很多“NexT”的fork版, 上面的地址是官方最新的版本。<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>是“NexT”的一个老版本。</p>
</blockquote>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li><p>克隆“NexT”主题到博客应用的themes目录</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改“应用配置”使用“NexT”主题</p>
<ul>
<li>theme: next</li>
</ul>
</li>
</ol>
<h3 id="对“NexT”主题的一些配置"><a href="#对“NexT”主题的一些配置" class="headerlink" title="对“NexT”主题的一些配置"></a>对“NexT”主题的一些配置</h3><p>这个段落加上后面的对接第三发系统部分将介绍一些常用的配置。如果需要更多的设置，可详细浏览“应用配置”和“主题配置”中的每一个可更改的配置，并参考对应的文档，或者Google、Baidu来了解配置的作用，分析是否能满足你的要求。</p>
<ul>
<li><p>去除页脚中的有关“NexT”的信息和链接</p>
<p>编辑“主题配置”，将“footer|powered|enable”，“footer|powerer|version”，“footer|theme|enable”以及“footer|theme|version”都设成“false”。</p>
</li>
<li><p>添加“about”和“tags”页<br>Hexo缺省支持这两个类型的页面。<br>(1) 执行下面的命令，在根目录下的source目录中分别创建“about”和“tags”文件夹</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>(2) 编辑“根目录/source/tags/index.md”，在头部加上“type: tags”</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-08</span><span class="number">-17</span> <span class="number">14</span><span class="string">:57:19</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>(3) 编辑“主题配置”，将“menu|about”和“menu|tags”打开</p>
</li>
<li><p>设置博客版面样式<br>也就是博客网站的样式，比如一列或者两列。可以通过“主题配置”中的“scheme”来设置。</p>
</li>
<li><p>开启博客首页文章自动摘录，以及摘录字数限制<br>编辑“主题配置”，将“auto_excerpt|enable”设成“true”，设置“auto_excerpt|length”为指定的摘录字数。</p>
<blockquote>
<p>根据描述，你也可以用符号“&lt;!-- more --&gt;”来精确控制自动摘录的结束点。</p>
</blockquote>
</li>
</ul>
<h2 id="对接第三发系统完善博客应用"><a href="#对接第三发系统完善博客应用" class="headerlink" title="对接第三发系统完善博客应用"></a>对接第三发系统完善博客应用</h2><p>由于Hexo产生的是静态博客网站，没有自己的独立数据库，所以很多功能需要利用第三方服务或者插件来完成。</p>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>如果不能科学上网的话，基本上不太可能使用国外的评论系统比如Disqus，Hypercomments，LiveRe等，要么访问速度慢，要么被墙。而国内可用的第三方评论系统也不是很多，多说和网易云跟帖已经关闭，畅言需要提供你的网站ICP备案号，否则只有15天的试用期。经过比较，发现Valine是一个比较轻量级的评论系统，速度快，不需要网站备案（说不定以后需要，先用着再说！）。</p>
<blockquote>
<p>如果非要尝试畅言的话，可以参考这个博客文章<a href="https://blog.csdn.net/qq_32518231/article/details/78080184" target="_blank" rel="noopener">https://blog.csdn.net/qq_32518231/article/details/78080184</a></p>
</blockquote>
<p>给你的博客应用设置Valine评论系统的步骤：<br>(1) 在LeanCloud<a href="https://www.leancloud.cn" target="_blank" rel="noopener">https://www.leancloud.cn</a>上注册一个账号；</p>
<blockquote>
<p>博客的评论将存储在LeadCloud中。</p>
</blockquote>
<p>(2) 进入控制台，创建一个开发版的应用；</p>
<p>(3) 点击进入这个应用，并进入设置|应用key页面获取APP ID和APP KEY；</p>
<p>(4) 修改主题配置，将valine|enable设为true，valine|appid设为上一步获取的APP ID，valine|appkey设为上一步获取的APP KEY。</p>
<blockquote>
<p>需要将你的静态博客发布到线上才会看到文章末尾的valine评论模块</p>
</blockquote>
<h3 id="文章统计"><a href="#文章统计" class="headerlink" title="文章统计"></a>文章统计</h3><ul>
<li><p>添加“文章字数”和“文章平均阅读时间”统计。</p>
<p>  (1) 在博客应用的根目录执行以下命令安装“hexo-sysmbols-count-time”插件</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>  (2) 修改<strong>应用配置</strong>添加以下配置加载“hexo-symbols-count-time”插件</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>  (3) 修改<strong>主题配置</strong>中的以下配置</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"><span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">item_text_total:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="社交分享"><a href="#社交分享" class="headerlink" title="社交分享"></a>社交分享</h3><p>添加模块<a href="https://github.com/theme-next/theme-next-needmoreshare2" target="_blank" rel="noopener">https://github.com/theme-next/theme-next-needmoreshare2</a>获得博客文章社交分享的功能。</p>
<p>(1) 执行以下命令安装needmoreshare模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-needmoreshare2 <span class="built_in">source</span>/lib/needsharebutton</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里一定得是克隆到“source/lib/needsharebutton”目录，名字不能错。</p>
</blockquote>
<p>(2) 修改“主题配置”“needmoreshare2”的子选项开启社交分享功能</p>
<h3 id="博客搜索"><a href="#博客搜索" class="headerlink" title="博客搜索"></a>博客搜索</h3><p>(1) 在博客应用的根目录安装插件<a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">https://github.com/theme-next/hexo-generator-searchdb</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>(2) 在“应用配置”中添加以下配置开启博客搜索功能</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="部署静态博客网站到码云-Gitee-静态页面空间"><a href="#部署静态博客网站到码云-Gitee-静态页面空间" class="headerlink" title="部署静态博客网站到码云(Gitee)静态页面空间"></a>部署静态博客网站到码云(Gitee)静态页面空间</h2><ol>
<li><p>在码云上创建一个与你账号同名的Git代码仓库，比如”ruokiy”;</p>
<blockquote>
<p>在创建时选择用README初始化仓库，这样创建出来的代码仓库缺省会带有master分支</p>
</blockquote>
</li>
<li><p>安装插件hexo-deployer-git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在“应用配置”中添加一下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">   <span class="attr">repo:</span> <span class="string">https://gitee.com/ruokiy/ruokiy.git</span></span><br><span class="line">   <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，最终deploy过程是将产生的静态博客网站文件提交到新创建的Git代码仓库的master分支上，所以做deploy的机子上需要能够写访问Git代码仓库。这里是通过https协议访问Git代码仓库的，所以你需要在deploy的机子上，也就是装有Git客户端的机子上设置以下的Git配置：<br>git config –global credential.helper store<br>尝试手动克隆一次代码仓库，根据提示输入用户名和密码，这样你的用户名和密码就会被缓存到机子上了。之后的访问都不要用户名和密码了。</p>
</blockquote>
</li>
<li><p>在博客应用的根目录执行以下命令完成静态博客文件的上传</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>如下图，在码云上点击刚创建的代码仓库页面，点击菜单“Service|Gitee Pages”，在左侧选择“master”分支，点击“create”按钮</p>
 <div align="center">
 <img src="/2018/08/17/setup-blog-hexo-gitee/2.png">
 </div>

</li>
</ol>
<p>不到一分钟，你的静态博客网站就生成了。可以拷贝生成的网址输入到浏览器打开你的博客了，同时你也可以把这个网址分享给你的朋友，或者放在你的个人简介中。</p>
<h1 id="最后一公里-将博客应用的代码托管到码云"><a href="#最后一公里-将博客应用的代码托管到码云" class="headerlink" title="最后一公里 - 将博客应用的代码托管到码云"></a>最后一公里 - 将博客应用的代码托管到码云</h1><p>这里会用到Git submodule的概念。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>【原】命令方式设置Windows Server网络代理</title>
    <url>/2020/02/03/windows-core-proxy/</url>
    <content><![CDATA[<p>在公司里的服务器往往需要配置网络代理才能访问外网，不同的操作系统设置代理的方式也不同，同一个操作系统在图形化和非图形化下的设置方式也不同。本文将详细介绍如何用命令的方式来设置Windows Server的网络代理，这种方式非常适合于非图形化的Windows Server Core的网络代理的设置，对图形化的Windows Server也同样适用。</p>
<a id="more"></a>

<h1 id="Windows-Server网络代理说明"><a href="#Windows-Server网络代理说明" class="headerlink" title="Windows Server网络代理说明"></a>Windows Server网络代理说明</h1><p>在图形化的Windows Server中设置网络代理相对来说比较简单，通常在IE浏览器的”Internet Options”里面设置即可：</p>
<img src="/2020/02/03/windows-core-proxy/1.png">

<p>但是这个网络代理只对一部分应用起作用，比如IE浏览器等。仍旧有些应用不是使用这个网络代理。在Windows Server环境中，有以下四类网络使用方式：</p>
<ul>
<li><p>使用WinINET库<br>WinINTE是IE浏览器的核心，同时也能被别的应用程序使用。使用WinINET的应用同样会使用IE浏览器的网络代理设置。</p>
</li>
<li><p>使用WinHTTP库<br>WinHTTP主要是被Windows中非交互式的应用所使用，比如需要访问网络的Windows服务或后台任务等。WinHTTP缺省不使用WinINET的网络代理设置。</p>
</li>
<li><p>Linux风格的网络代理<br>许多Linux用户在使用Windows时仍然希望使用Linux相关的命令，他们往往通过安装<a href="https://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a>，或者<a href="http://getgnuwin32.sourceforge.net/" target="_blank" rel="noopener">GunWin32</a>来引入Linux命令，而涉及到网络操作的命令则是通过Linux风格的网络代理来访问网络。Linux系统一般是以非图形化的方式作为服务器，所以其网络代理设置通常只需要设置环境变量：https_proxy, http_proxy和no_proxy，而桌面版的Linux是带有图形化的，其网络设置除了三个环境变量外，还需要其它地方的设置，否则那些图形化的应用将无法访问网络。本文将只介绍非图形化的Linux网络代理设置。</p>
</li>
<li><p>应用级别的网络代理设置<br>有些应用本身支持设置自己的网络代理，而不依赖于系统设置的代理。这些应用本身会实现很多底层的操作，比如直接使用Winsock建立网络连接。</p>
</li>
</ul>
<p>接下来将详细介绍WinINET，WinHTTP和Linux风格的网络代理设置。</p>
<h1 id="设置WinINET类型的网络代理"><a href="#设置WinINET类型的网络代理" class="headerlink" title="设置WinINET类型的网络代理"></a>设置WinINET类型的网络代理</h1><h2 id="设置自动代理脚本"><a href="#设置自动代理脚本" class="headerlink" title="设置自动代理脚本"></a>设置自动代理脚本</h2><figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$proxyScript</span> = <span class="string">"http://&lt;your url&gt;/proxy.pac"</span></span><br><span class="line"><span class="variable">$regs</span> = <span class="string">"HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings"</span>,<span class="string">"HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings"</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$reg</span> <span class="keyword">in</span> <span class="variable">$regs</span>)&#123;</span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> AutoConfigURL <span class="literal">-Value</span> <span class="variable">$proxyScript</span></span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyEnable <span class="literal">-Value</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置手动代理"><a href="#设置手动代理" class="headerlink" title="设置手动代理"></a>设置手动代理</h2><p>参考:<br><a href="https://config9.com/windows/powershell/using-powershell-to-programmatically-configure-internet-explorer-proxy-settings-to-work-before-it-has-been-opened/" target="_blank" rel="noopener">https://config9.com/windows/powershell/using-powershell-to-programmatically-configure-internet-explorer-proxy-settings-to-work-before-it-has-been-opened/</a></p>
<h3 id="系统级别的设置"><a href="#系统级别的设置" class="headerlink" title="系统级别的设置"></a>系统级别的设置</h3><figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$proxy</span>=<span class="string">"http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="variable">$bypassList</span>=<span class="string">"&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$proxyString</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$proxy</span>)).length); <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">2</span> <span class="operator">-eq</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$proxy</span>))[<span class="variable">$i</span>])</span><br><span class="line">        <span class="variable">$convertedByte</span>=%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$byte</span>,<span class="number">16</span>)&#125;</span><br><span class="line">        <span class="variable">$proxyString</span> = <span class="variable">$proxystring</span> + <span class="variable">$convertedByte</span>  + <span class="string">","</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bypassString</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$bypassList</span>)).length); <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">2</span> <span class="operator">-eq</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$bypassList</span>))[<span class="variable">$i</span>])</span><br><span class="line">        <span class="variable">$convertedByte</span>=%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$byte</span>,<span class="number">16</span>)&#125;</span><br><span class="line">        <span class="variable">$bypassString</span> = <span class="variable">$bypassString</span> + <span class="variable">$convertedByte</span>  + <span class="string">","</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$regString</span>=<span class="string">"46,00,00,00,00,00,00,00,0b,00,00,00,"</span>+(%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$proxy</span>.length,<span class="number">16</span>)&#125;)+<span class="string">",00,00,00,"</span> + <span class="variable">$proxystring</span> + (%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$bypassList</span>.length,<span class="number">16</span>)&#125;) + <span class="string">",00,00,00,"</span> + <span class="variable">$bypassString</span> +  <span class="string">"00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"</span></span><br><span class="line"><span class="variable">$regstringAsArray</span> = (<span class="string">"0x"</span>+<span class="variable">$regString</span>.replace(<span class="string">","</span>,<span class="string">",0x"</span>)).Split(<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">"HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings"</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxySettingsPerUser <span class="literal">-Value</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$regs</span> = <span class="string">"HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings"</span>,<span class="string">"HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings"</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$reg</span> <span class="keyword">in</span> <span class="variable">$regs</span>)&#123;</span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyServer <span class="literal">-Value</span> <span class="variable">$proxy</span></span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyEnable <span class="literal">-Value</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyOverride <span class="literal">-Value</span> <span class="variable">$bypassList</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$regs</span> = <span class="string">"HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"</span>,<span class="string">"HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$reg</span> <span class="keyword">in</span> <span class="variable">$regs</span>)&#123;</span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> DefaultConnectionSettings <span class="literal">-Type</span> Binary <span class="literal">-Value</span> <span class="variable">$regstringAsArray</span></span><br><span class="line">    <span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> SavedLegacySettings <span class="literal">-Type</span> Binary <span class="literal">-Value</span> <span class="variable">$regstringAsArray</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户级别的设置"><a href="#用户级别的设置" class="headerlink" title="用户级别的设置"></a>用户级别的设置</h3><figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$proxy</span>=<span class="string">"http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="variable">$bypassList</span>=<span class="string">"&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$proxyString</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$proxy</span>)).length); <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">2</span> <span class="operator">-eq</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$proxy</span>))[<span class="variable">$i</span>])</span><br><span class="line">        <span class="variable">$convertedByte</span>=%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$byte</span>,<span class="number">16</span>)&#125;</span><br><span class="line">        <span class="variable">$proxyString</span> = <span class="variable">$proxystring</span> + <span class="variable">$convertedByte</span>  + <span class="string">","</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$bypassString</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$bypassList</span>)).length); <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$i</span> % <span class="number">2</span> <span class="operator">-eq</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable">$byte</span> = (([<span class="type">System.Text.Encoding</span>]::Unicode.GetBytes(<span class="variable">$bypassList</span>))[<span class="variable">$i</span>])</span><br><span class="line">        <span class="variable">$convertedByte</span>=%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$byte</span>,<span class="number">16</span>)&#125;</span><br><span class="line">        <span class="variable">$bypassString</span> = <span class="variable">$bypassString</span> + <span class="variable">$convertedByte</span>  + <span class="string">","</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$regString</span>=<span class="string">"46,00,00,00,00,00,00,00,0b,00,00,00,"</span>+(%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$proxy</span>.length,<span class="number">16</span>)&#125;)+<span class="string">",00,00,00,"</span> + <span class="variable">$proxystring</span> + (%&#123;[<span class="type">System.Convert</span>]::ToString(<span class="variable">$bypassList</span>.length,<span class="number">16</span>)&#125;) + <span class="string">",00,00,00,"</span> + <span class="variable">$bypassString</span> +  <span class="string">"00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"</span></span><br><span class="line"><span class="variable">$regstringAsArray</span> = (<span class="string">"0x"</span>+<span class="variable">$regString</span>.replace(<span class="string">","</span>,<span class="string">",0x"</span>)).Split(<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">"HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet Settings"</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxySettingsPerUser <span class="literal">-Value</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">"HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings"</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyServer <span class="literal">-Value</span> <span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyEnable <span class="literal">-Value</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> ProxyOverride <span class="literal">-Value</span> <span class="variable">$bypassList</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">"HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> DefaultConnectionSettings <span class="literal">-Type</span> Binary <span class="literal">-Value</span> <span class="variable">$regstringAsArray</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> SavedLegacySettings <span class="literal">-Type</span> Binary <span class="literal">-Value</span> <span class="variable">$regstringAsArray</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows代理的忽略列表支持通配符*</p>
</blockquote>
<h1 id="设置WinHTTP类型的网络代理"><a href="#设置WinHTTP类型的网络代理" class="headerlink" title="设置WinHTTP类型的网络代理"></a>设置WinHTTP类型的网络代理</h1><figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">netsh winhttp set proxy proxy<span class="literal">-server</span>=<span class="string">"http=&lt;server&gt;:&lt;port&gt;;https=&lt;server&gt;:&lt;port&gt;;ftp=&lt;server&gt;:&lt;port&gt;"</span> bypass<span class="literal">-list</span>=<span class="string">"&lt;local&gt;;*.xxxx.com;xxxx.com;192.168.56.*;10.0.0.*"</span></span><br></pre></td></tr></table></figure>

<p>如果WinINET设置的是手动网络代理，也可以导入WinINET的网络代理：</p>
<figure class="highlight ps"><table><tr><td class="code"><pre><span class="line">netsh winhttp import proxy ie</span><br></pre></td></tr></table></figure>

<h1 id="设置Linux风格的网络代理"><a href="#设置Linux风格的网络代理" class="headerlink" title="设置Linux风格的网络代理"></a>设置Linux风格的网络代理</h1><figure class="highlight ps"><table><tr><td class="code"><pre><span class="line"><span class="variable">$httpProxy</span> = <span class="string">"http://&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="variable">$httpsProxy</span> = <span class="string">"http://&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="variable">$noProxy</span> = <span class="string">"localhost,127.0.0.1,.xxxx.com,xxxx.com,192.168.0.5"</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$reg</span> = <span class="string">"HKLM:\SYSTEM\ControlSet001\Control\Session Manager\Environment"</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> https_proxy <span class="literal">-Value</span> <span class="variable">$httpProxy</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> http_proxy <span class="literal">-Value</span> <span class="variable">$httpsProxy</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> no_proxy <span class="literal">-Value</span> <span class="variable">$noProxy</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> HTTPS_PROXY <span class="literal">-Value</span> <span class="variable">$httpProxy</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> HTTP_PROXY <span class="literal">-Value</span> <span class="variable">$httpsProxy</span></span><br><span class="line"><span class="built_in">Set-ItemProperty</span> <span class="literal">-Path</span> <span class="variable">$reg</span> <span class="literal">-Name</span> NO_PROXY <span class="literal">-Value</span> <span class="variable">$noProxy</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Linux代理的忽略列表不支持通配符，比如*，但可以只增加域名后缀来匹配一系列域名<br>大小写的环境变量都设置了一遍，因为在实际工作中发现存在着一些应用或命令只识别大写或小写</p>
</blockquote>
<h1 id="Ansible脚本设置网络代理"><a href="#Ansible脚本设置网络代理" class="headerlink" title="Ansible脚本设置网络代理"></a>Ansible脚本设置网络代理</h1><p>以上设置网络代理的方式其实就是我们所说的ad-hoc脚本的方式，但是ad-hoc脚本在不同的Windows系统中移植性比较差，往往需要一些改动才能运行。使用配置管理工具比如Ansible来设置网络代理往往会带来两个好处：</p>
<ul>
<li>可移植性</li>
<li>更少的代码</li>
</ul>
<p>这也是我们所说的“现成的工具优先于专门脚本(tool over ad-hoc)”这一最佳实践。</p>
<p>以下是Ansible脚本样本：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">IE</span> <span class="string">proxy</span> <span class="string">settings</span> <span class="string">to</span> <span class="string">apply</span> <span class="string">to</span> <span class="string">all</span> <span class="string">users</span></span><br><span class="line">  <span class="attr">win_regedit:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">HKLM:\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet</span> <span class="string">Settings</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ProxySettingsPerUser</span></span><br><span class="line">    <span class="attr">data:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">dword</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">IE</span> <span class="string">to</span> <span class="string">use</span> <span class="string">a</span> <span class="string">specific</span> <span class="string">proxy</span> <span class="string">per</span> <span class="string">protocol</span> <span class="string">using</span> <span class="string">a</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">win_inet_proxy:</span></span><br><span class="line">    <span class="attr">proxy:</span> <span class="string">http=&#123;&#123;win_init_http_proxy&#125;&#125;;https=&#123;&#123;win_init_https_proxy&#125;&#125;;ftp=&#123;&#123;win_init_ftp_proxy&#125;&#125;</span></span><br><span class="line">    <span class="attr">bypass:</span> <span class="string">"<span class="template-variable">&#123;&#123;win_init_no_proxy&#125;&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This should be done after setting the IE proxy with win_inet_proxy</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Import</span> <span class="string">IE</span> <span class="string">proxy</span> <span class="string">configuration</span> <span class="string">to</span> <span class="string">WinHTTP</span></span><br><span class="line">  <span class="attr">win_http_proxy:</span></span><br><span class="line">    <span class="attr">source:</span> <span class="string">ie</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="string">http</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http_proxy</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_http_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="string">https</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https_proxy</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_https_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="literal">no</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">no_proxy</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_no_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="string">HTTP</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">HTTP_PROXY</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_http_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="string">HTTPS</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">HTTPS_PROXY</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_https_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Linux</span> <span class="string">style</span> <span class="literal">NO</span> <span class="string">proxy</span></span><br><span class="line">  <span class="attr">win_environment:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">NO_PROXY</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">'<span class="template-variable">&#123;&#123;linux_style_init_no_proxy&#125;&#125;</span>'</span></span><br><span class="line">    <span class="attr">level:</span> <span class="string">machine</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">present</span></span><br></pre></td></tr></table></figure>

<p>变量：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">win_init_http_proxy:</span> <span class="string">"&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="attr">win_init_https_proxy:</span> <span class="string">"&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="attr">win_init_ftp_proxy:</span> <span class="string">"&lt;server&gt;:&lt;port&gt;"</span></span><br><span class="line"><span class="attr">win_init_no_proxy:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"*.xxxx.com"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"192.168.56.*"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"10.0.0.*"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">linux_style_init_http_proxy:</span> <span class="string">http://&lt;server&gt;:&lt;port&gt;</span></span><br><span class="line"><span class="attr">linux_style_init_https_proxy:</span> <span class="string">http://&lt;server&gt;:&lt;port&gt;</span></span><br><span class="line"><span class="attr">linux_style_init_ftp_proxy:</span> <span class="string">http://&lt;server&gt;:&lt;port&gt;</span></span><br><span class="line"><span class="attr">linux_style_init_no_proxy:</span> <span class="string">"localhost,127.0.0.1,.xxxx.com,xxxx.com,192.168.0.5"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】GitOps(1) 什么是GitOps?</title>
    <url>/2019/07/21/gitops/</url>
    <content><![CDATA[<center>[原文] [https://www.weave.works/technologies/gitops/][1]</center>
您是否听说过GitOps并且也想知道它到底是什么？ 本文，我们将介绍GitOps工作流的原理和模式，以及如何实现它们以便在生产环境中规模化运行Kubernetes。 我们还将描述GitOps与基础架构代码（IAC)，配置管理工具之间的差异，当然还将向您展示如何将GitOps最佳实践作为您自己的开发环境的一部分。
<a id="more"></a>

<h1 id="GitOps是什么"><a href="#GitOps是什么" class="headerlink" title="GitOps是什么?"></a>GitOps是什么?</h1><p><img src="1.png" alt></p>
<p><strong>GitOps</strong> Kubernetes集群管理和应用程序交付的一种方法。它是用Git作为声明式基础架构和应用程序的单一事实来源。通过将Git作为交付管道的中心，开发可以通过拉取请求(Pull Request)来加速和简化Kubernetes应用程序的部署和运维任务。</p>
<p><strong>一种构建云原生应用的操作模式</strong></p>
<p>GitOps可以概括为以下两点:</p>
<ol>
<li>Kubernetes和其它云原生技术的一种操作模式，提供一组统一部署，管理和监控容器化集群和应用程序的最佳实践。</li>
<li>面向开发者的管理应用程序的经验，将端到端的CI/CD管道和Git工作流应用于运维和开发。</li>
</ol>
<h1 id="GitOps的主要优点"><a href="#GitOps的主要优点" class="headerlink" title="GitOps的主要优点"></a>GitOps的主要优点</h1><p>当Git中有变更发生时，自动化交付管道会自动变更你的基础架构。然而GitOps概念远不止于此 - 它使用工具将整个应用程序的实际生产状态与源码管理工具中的代码进行比较，当你的集群与实际状态不符时，给出提醒。</p>
<p>通过应用GitOps最佳实践，你的基础架构和应用程序会有一个“事实来源”，这将提高开发团队的速度并提高系统可靠性。</p>
<p>采用GitOps最佳实践的好处是深远的，并提供：</p>
<ol>
<li><p><strong>提高生产力</strong><br>自动化的持续部署加上集成的反馈控制回路提升了平均部署时间。你的团队每天能够提交30到100倍的更多变更，将总体开发输出提高2到3倍。</p>
</li>
<li><p><strong>增强开发体验</strong><br>推送代码而不是容器。开发不需要深入了解Kubernetes就可以使用熟悉的工具(比如Git)快速地更新Kubernetes应用和添加新的功能。新入职的开发能够在几天内而不是几个月内快速地提升开发效率。</p>
</li>
<li><p><strong>提高稳定性</strong><br>当你使用Git工作流管理你的集群时，你不需要通过Kubernetes就能够自动获取便于审核的集群的所有变更日志。通过审核跟踪谁在何时变更了你的集群能够满足SOC 2合规性并能确保稳定性。 </p>
</li>
<li><p><strong>高可用性</strong><br>借助Git恢复/回滚和分叉功能，你将获得稳定并可重复的回滚功能。因为你通过Git描述了整个系统，你将有一个单一的事实来源用来从崩溃中恢复，从而将你的恢复时间(MTTR)从几小时降到几分钟。</p>
</li>
<li><p><strong>一致性和标准化</strong><br>由于GitOps提供了统一的模型用来变更基础架构，应用以及Kubernetes add-on，你可以在整个组织中实现一致的端到端的工作流。不仅你的持续集成和持续交付管道通过拉取请求(Pull Request)驱动，你的操作任务通过Git也完全可以重现。</p>
</li>
<li><p><strong>更健壮的安全保证</strong><br>Git的强正确性以及安全保证(背后是健壮的用于追踪和管理变更的加密技术)，以及签名变更以证明作者身份和来源的能力是安全定义集群目标状态的关键。</p>
</li>
</ol>
<h1 id="GitOps是满足云原生的持续交付"><a href="#GitOps是满足云原生的持续交付" class="headerlink" title="GitOps是满足云原生的持续交付"></a>GitOps是满足云原生的持续交付</h1><p>GitOps是从DevOpsSite Reliability Engineering(站点可靠性工程)的想法中逐渐演变出来的，这些想法始于<a href="https://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">2016念Martin Fowler对持续集成的全面概述</a></p>
<h2 id="自由选择所需的工具"><a href="#自由选择所需的工具" class="headerlink" title="自由选择所需的工具"></a>自由选择所需的工具</h2><p>作为CI/CD管道的一个工作流，GitOps被<a href="https://martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">描述为开发过程的圣杯</a>。由于没有单一的工具能够完成CI/CD管道中所有的工作，GitOps可以让你为每个部分选择最佳的工具。你可以从开源生态系统选择一组工具，也可以从闭源中选择一组工具，你甚至可以根据你的具体情况，组合使用它们。创建CI/CD管道最困难的部分是将所有的工具组合在一起。</p>
<p>无论你选择什么工具来构建交付管道，通过Git(或任何版本管理系统)应用GitOps的最佳实践都应该是你流程中不可或缺的组成部分。这样做可以轻松地过渡到持续交付。不论是从技术角度还是从文化角度都应该如此。</p>
<h1 id="GitOps的原则"><a href="#GitOps的原则" class="headerlink" title="GitOps的原则"></a>GitOps的原则</h1><p>开始使用GitOps工作流管理你的集群，必须具备以下条件：</p>
<p><strong>1. 整个系统以声明方式描述</strong><br>Kubernetes只是众多现代云原生工具的一个例子，它们是可“声明的”，可以被视为代码。可声明意味着配置是由一组事实而不是一组指令来保证的。将你的应用的声明版本管理到Git，你只有一个事实来源。你可以轻松地部署和回滚Kubernetes的应用。更重要的是，当灾难发生时，你可以快速可靠地重现集群的基础架构。</p>
<p><strong>2. 在Git中管理规范的目标系统状态版本</strong><br>通过将你系统的声明存储在版本管理系统中，并作为你的规范性事实来源，你可以从一个地方获取和驱动所有的内容。这简化了回滚操作，你可以使用“Git Revert”来回滚到之前的应用程序状态。借助Git出色的安全保障，你可以使用SSH密钥对提交进行签名，从而对代码的作者和来源实施强有力的安全保障。 </p>
<p><strong>3. 批准的更改可以自动应用于系统</strong><br>一旦将声明的状态保存在Git中，下一步就是允许对该状态的任何更改都能够被自动应用于你的系统。有意义的是，你不需要集群的账号来更改你的系统。借助于GitOps，状态定义存在于这个隔离环境之外。这使你可以解耦做什么与如何做。</p>
<p><strong>4. 软件代理确保差异的正确性并报警</strong><br>一旦你的系统状态被声明并保存在版本控制系统中，每当实际状态与期望状态不符，软件代理就可以通知你。代理的使用还可以确保你的整个系统是自修复的。通过自修复，不仅仅是指节点或pod失败时(Kubernetes会处理这类失败)，而是在更广泛的意义上，比如人为错误的情况。在这种情况下，软件代理充当了你的操作的反馈和控制闭环。</p>
<h1 id="Git赋能基础架构即代码-IAC-工具"><a href="#Git赋能基础架构即代码-IAC-工具" class="headerlink" title="Git赋能基础架构即代码(IAC)工具"></a>Git赋能基础架构即代码(IAC)工具</h1><p>Kubernetes只是众多现代云原生工具的一个例子，它们是可“声明的”，可以被视为代码。可声明意味着配置是由一组事实而不是一组指令来保证的。例如，“有十个redis服务器”，而不是“启动十个redis服务器”，并且提示我可行。</p>
<p>借助声明式工具，你的整个配置文件可以在Git中进行版本管理。通过使用Git作为事实来源，你可以轻松地部署和回滚Kubernetes的应用。更重要的是，当灾难发生时，你可以从Git中快速可靠地重现集群的基础架构。</p>
<h2 id="IAC工具-vs-GitOps"><a href="#IAC工具-vs-GitOps" class="headerlink" title="IAC工具 vs. GitOps"></a>IAC工具 vs. GitOps</h2><p>作为能够按要求创建服务器的基础架构即代码工具已经存在相当长的一段时间了。这些工具产生了保持基础架构及代码配置版本化，可备份化以及可重现的概念。</p>
<p>但是现在由于Kubernetes几乎完全是声明性的，结合不可变容器，可以将这些概念中的一些扩展到管理应用程序及其操作系统。</p>
<p>能够管理和比较基础架构和应用程序的当前状态，以便借助使用Git完整的审计跟踪，你能测试，部署，回滚和前滚，这是GitOps理念及其最佳实践内容。这是可行的，因为Kubernetes几乎完全通过声明性配置进行管理，以及容器也是不可变的。</p>
<p>在Weaveworks，我们使用Terraform和Ansible来创建服务器。我们将那些配置文件保存在Git中进行版本管理。IAC工具及其相关的配置文件构成了我们GitOps工作流的核心部分，如果发生灾难，可以做到近乎实时的集群恢复。通过<a href="http://www.weave.works/technologies/gitops-frequently-asked-questions" target="_blank" rel="noopener">GitOps FAQ</a>了解更多的基础架构及代码与GitOps的区别。</p>
<h2 id="我的系统与事实来源出现差异该如何？"><a href="#我的系统与事实来源出现差异该如何？" class="headerlink" title="我的系统与事实来源出现差异该如何？"></a>我的系统与事实来源出现差异该如何？</h2><p>声明式工具允许你在Git中描述期望的真实状态。但是在实际系统中的真实状态可能会有问题，这可能与版本管理系统中描述的状态有差别。</p>
<ul>
<li>你如何知道实际系统达到了期望状态？  </li>
<li>当有差异时，你能得到通知吗？  </li>
<li>有什么机制类似于“煤矿中的金丝雀”在你遇到麻烦时通知你？</li>
<li>你如何触发集群与版本管理系统之前的同步？</li>
</ul>
<p>这里有现成的技术.</p>
<p>IAC工具，比如Chef，Puppet和Ansible支持“差异警告”功能。这有助于运维人员知道何时应该采取行动将实际系统收敛到期望状态（通过配置脚本定义的）。甚至最近，最佳实践是部署不可变镜像（比如容器），以便尽可能减少差异。</p>
<p>在“GitOps”模型中，在一组用来比较期望状态和实际状态的“比较”和“同步”工具（<a href="https://github.com/weaveworks/kubediff" target="_blank" rel="noopener">kubediff</a>, 以及 terradiff 和ansiblediff）的辅助下，我们使用Git解决差异和收敛。</p>
<h2 id="GitOps构建在不可变基础架构之上"><a href="#GitOps构建在不可变基础架构之上" class="headerlink" title="GitOps构建在不可变基础架构之上"></a>GitOps构建在不可变基础架构之上</h2><p>GitOps充分利用不断发展的不可变基础架构和声明式容器编排。在Weaveworks，我们一天部署多次。为了降低部署后变更的风险，无论是有意的还是偶然的“配置偏差”，我们必须维护一个可重现且可靠的部署过程。</p>
<p>我们整个系统的期望状态（也就是“事实来源”）是在Git中描述的。我们使用容器实现不可变性，以及Terraform和Ansible等不同的云原生工具来自动化和管理我们的配置。这些工具与容器以及Kubernetes声明性的本质一起提供了在发生灾难时完整恢复所需要的东西。</p>
<h2 id="与IAC工具协作"><a href="#与IAC工具协作" class="headerlink" title="与IAC工具协作"></a>与IAC工具协作</h2><p>当你将GitOps原则应用于“所有方面”时，除了报警规则和仪表盘之外包括机器配置，应用程序和服务，所有这些都保存在版本管理系统中。</p>
<p>除非通过Git，否则不需要访问正在运行的系统。任何一组更改都可以是原子性的，并且能够做相应地比较。Git记录也不仅仅是审计日志，还是可用于在任何快照之前来回滚动的事物日志。</p>
<h1 id="Weave-Cloud的持续交付和GitOps工作流"><a href="#Weave-Cloud的持续交付和GitOps工作流" class="headerlink" title="Weave Cloud的持续交付和GitOps工作流"></a>Weave Cloud的持续交付和GitOps工作流</h1><p>在我们的产品<a href="https://cloud.weave.works/signup" target="_blank" rel="noopener">Weave Cloud</a>中, GitOps的核心机制已经内置于CI/CD的工具中了，关键部分是持续部署(CD)，<a href="https://github.com/weaveworks/flux/blob/master/site/introduction.md#automated-git-cluster-synchronisation" target="_blank" rel="noopener">支持Git-cluster同步</a>。</p>
<p>Weave Cloud是专门为版本控制系统和声明式应用程序栈设计的。团队中的每个开发人员都可能熟悉Git且能够创建拉取请求(Pull Request)。现在，他们也能够使用Git加速并简化Kubernetes应用的部署。</p>
<p>以下是以典型的创建和更新一个新功能的开发流程：</p>
<ol>
<li>推送一个新功能的拉取请求(Pull Request)到GitHub进行审核。</li>
<li>代码被同事审核并批准后，被合并到Git。</li>
<li>Git合并触发CI流水线，通过一系列测试后，新构建出来的镜像被存储到镜像仓库里。</li>
<li>Weave Cloud的“Deployment Automator” 检测到镜像仓库中有新的镜像，从仓库中拉取新的镜像并跟新配置仓库中的YAML文件。</li>
<li>Weave Cloud的“Deployment Synchronizer” (运行在集群中)，检测到集群有更新，它从配置仓库中拉取变更后的清单并将新的功能部署到生产环境中。</li>
</ol>
<p><strong>支持GitOps的CI/CD管道：</strong></p>
<p><img src="1.png" alt></p>
<h2 id="使用Operator模式实现的Kubernetes控制器"><a href="#使用Operator模式实现的Kubernetes控制器" class="headerlink" title="使用Operator模式实现的Kubernetes控制器"></a>使用Operator模式实现的Kubernetes控制器</h2><p>Weave Cloud实现了以自定义的控制器用来监听和同步你的Kubernetes集群。控制器是使用Operator模式实现的，有两个层面的意义：首先，它更安全；其次，它能够自动处理复杂的易错的任务，比如必须手动更新YAML清单。</p>
<p>通过使用Operator模式，代理会代表集群监控自定义资源变更事件，以便部署这些变更。代理负责同步Git与集群，并且为你的团队提供了一种实现持续部署的简单方法。</p>
<h2 id="拉-vs-推管道"><a href="#拉-vs-推管道" class="headerlink" title="拉 vs 推管道"></a>拉 vs 推管道</h2><p><strong>推管道</strong><br>目前大部分CI/CD工具使用推模型。基于推模型的管道意味着代码从CI系统开始，通过一系列的脚本或者手动使用“kubectl”将变更推到Kubernetes集群。</p>
<p>你不希望使用CI系统触发部署或者通过命令行手动部署，原因是可能在集群之外泄露账号。虽然可以保护你的CI/CD脚本和命令行，但你是在集群信任域之外工作。这通常不是好的做法，这也是为什么CI系统能被为生产环境攻击的载体。</p>
<p>具有集群外部读/写权限的推式的管道：<br><img src="2.png" alt></p>
<p>在Weave Cloud中，在集群内部保存账号并拉取镜像：<br><img src="3.png" alt></p>
<p><strong>Weave Cloud拉管道</strong><br>Weave Cloud使用由两个关键组件组成的拉取策略：一个是监测镜像仓库的”Deployment Automator”和一个集群中以维持其状态的”Deployment Synchronizer”。</p>
<p>在我们拉取管道模式的中心是清单（或配置仓库）的单一事实来源。开发将他们的更新代码推送到代码仓库，CI工具获取更改并最终构建出Docker镜像。Weave Cloud的“Deployment Automator”检测到新的镜像，从镜像仓库中拉取新的镜像并更新配置仓库中的YAML配置。“Deployment Synchronizer”检测到集群已经过期，并从配置仓库中拉取更改的清单，并将新的镜像部署到集群。</p>
<p><strong>安装在集群中的Weave Cloud部署代理</strong><br>使用群集内部的Deployment Synchronizer，你的群集账号不会在生产环境之外公开。 一旦Weave Cloud代理安装到你的集群并且与你的Git仓库已连接，你的生产环境中的任何更改都将通过具有完全回滚的Git拉请求(Pull Request)以及Git提供的方便审计日志完成。<br><img src="4.png" alt></p>
<p><strong>可观察性是部署的催化剂</strong><br>通过Kubernetes，GitOps可以通过拉取请求(Pull Request)管理基础架构和应用程序。但是GitOps工作流和可观察性如何协同工作？</p>
<p>通过GitOps工作流和实时可观察性，你的开发团队可以在部署任何新功能之前做出关键决策。由于在发布之前你可以在正在运行的集群中实时观察即将发布的服务，这意味着你能够自信，快速地部署并交付更高质量的功能。</p>
<p>可观察性可以被视为Kubernetes<a href="https://continuousdelivery.com/" target="_blank" rel="noopener">持续交付</a>周期的主要驱动因素之一，因为它描述了任何给定时间的系统实际运行状态。观察运行系统以便理解和控制它。新功能和修复被推送到Git并触发部署管道，何时准备发布可以通过实时观察正在运行的集群。此时，根据此反馈，开发人员可以返回到管道的开始，或者部署并发布到产品集群中。</p>
<p>GitOps是面向发布的操作和功能模型。你向客户交付新功能的速度有多快，部分取决你的团队在此周期中通过各阶段的速度。<br><img src="5.png" alt></p>
<p>使用GitOps工作流和可观察性的开发人员需要回答这些问题：</p>
<ol>
<li>如果自动发布一个变更，我们如何知道它确实有效？</li>
<li>如何确定我们的变更实际是在驱动改进？</li>
<li>在复杂的分布式系统中，我们如何理解，诊断问题并处理事件？</li>
</ol>
<p>通过Weave Cloud，可观察工作负载仪表盘已集成到部署和发布流程中。在承诺将部署发布到准备环境或生产环境之前，你可以看到部署是否成功。这不仅帮助你更快地识别问题，而且由于可观察性工作负载仪表盘是实时的并且内置于部署过程中，你可以自信的一天多次地部署你的服务并确信部署没有重大缺陷。<br><img src="6.png" alt></p>
<h1 id="GitOps的优点"><a href="#GitOps的优点" class="headerlink" title="GitOps的优点"></a>GitOps的优点</h1><p><strong>更快的部署</strong><br>通过采用GitOps的最佳实践，开发人员可以使用熟悉的工具比如Git来快速地管理Kubernetes应用的更新和新功能。通过持续的推送功能更新，企业变得更加敏捷，能够更快地反应客户需求，并在市场中更具竞争力。</p>
<p><strong>更好的操作</strong><br>使用GitOps，你拥有一个完整的端到端的管道。不仅你的持续集成和持续交付管道都是由拉取请求(Pull Request)驱动，而且你的操作任务也可以通过Git完全重现。</p>
<p>如果你正在使用Weave Cloud，可以安全地部署到正在运行的集群中，不会将敏感的账号泄露在集群之外。</p>
<p><strong>更健壮的安全保证</strong><br>Git的强正确性以及安全保证(背后是健壮的用于追踪和管理变更的加密技术)，以及对变更的签名从而证明作者身份和来源的能力是正确和安全地定义集群目标状态的关键。如果发生安全漏洞，可以独立于脆弱的系统使用不可变和可审计的事实来源重新创建新的系统，从而减少停机时间并允许更好的事件响应。</p>
<p>打包软件和发布到生产环境的职责分离也体现了最小特权的安全原则，减少脆弱影响并提供了更小的攻击面。</p>
<p><strong>使得合规和审核更容易</strong><br>由于以安全的方式追踪和和记录更改，因此合规性和审计变得微不足道。使用kubediff，terradiff和ansiblediff可以将集群的可信任状态定义与实际运行的集群进行比较，从而确保可追踪和审核的变更与实际相符。</p>
]]></content>
      <tags>
        <tag>DevOps</tag>
        <tag>CI/CD</tag>
        <tag>GitOps</tag>
      </tags>
  </entry>
</search>
